diff --git a/NEWS b/NEWS
index 485b8ddffa..3030735839 100644
--- a/NEWS
+++ b/NEWS
@@ -5,6 +5,17 @@ See the end for copying conditions.
 Please send GNU C library bug reports via <https://sourceware.org/bugzilla/>
 using `glibc' in the "product" field.
 
+The following bugs are resolved with this release:
+
+  [26534] libm.so 2.32 SIGILL in pow() due to FMA4 instruction on non-FMA4
+    system
+  [26555] string: strerrorname_np does not return the documented value
+  [26636] libc: 32-bit shmctl(IPC_INFO) crashes when shminfo struct is
+    at the end of a memory mapping
+  [26637] libc: semctl SEM_STAT_ANY fails to pass the buffer specified
+    by the caller to the kernel
+  [26639] libc: msgctl IPC_INFO and MSG_INFO return garbage
+
 Version 2.32
 
 Major new features:
diff --git a/iconv/Versions b/iconv/Versions
index 8a5f4cf780..d51af52fa3 100644
--- a/iconv/Versions
+++ b/iconv/Versions
@@ -6,7 +6,9 @@ libc {
   GLIBC_PRIVATE {
     # functions shared with iconv program
     __gconv_get_alias_db; __gconv_get_cache; __gconv_get_modules_db;
-    __gconv_open; __gconv_create_spec;
+
+    # functions used elsewhere in glibc
+    __gconv_open; __gconv_create_spec; __gconv_destroy_spec;
 
     # function used by the gconv modules
     __gconv_transliterate;
diff --git a/iconv/gconv_charset.c b/iconv/gconv_charset.c
index 6ccd0773cc..4ba0aa99f5 100644
--- a/iconv/gconv_charset.c
+++ b/iconv/gconv_charset.c
@@ -216,3 +216,13 @@ out:
   return ret;
 }
 libc_hidden_def (__gconv_create_spec)
+
+
+void
+__gconv_destroy_spec (struct gconv_spec *conv_spec)
+{
+  free (conv_spec->fromcode);
+  free (conv_spec->tocode);
+  return;
+}
+libc_hidden_def (__gconv_destroy_spec)
diff --git a/iconv/gconv_charset.h b/iconv/gconv_charset.h
index b39b09aea1..e9c122cf7e 100644
--- a/iconv/gconv_charset.h
+++ b/iconv/gconv_charset.h
@@ -48,33 +48,6 @@
 #define GCONV_IGNORE_ERRORS_SUFFIX "IGNORE"
 
 
-/* This function accepts the charset names of the source and destination of the
-   conversion and populates *conv_spec with an equivalent conversion
-   specification that may later be used by __gconv_open.  The charset names
-   might contain options in the form of suffixes that alter the conversion,
-   e.g. "ISO-10646/UTF-8/TRANSLIT".  It processes the charset names, ignoring
-   and truncating any suffix options in fromcode, and processing and truncating
-   any suffix options in tocode.  Supported suffix options ("TRANSLIT" or
-   "IGNORE") when found in tocode lead to the corresponding flag in *conv_spec
-   to be set to true.  Unrecognized suffix options are silently discarded.  If
-   the function succeeds, it returns conv_spec back to the caller.  It returns
-   NULL upon failure.  */
-struct gconv_spec *
-__gconv_create_spec (struct gconv_spec *conv_spec, const char *fromcode,
-                     const char *tocode);
-libc_hidden_proto (__gconv_create_spec)
-
-
-/* This function frees all heap memory allocated by __gconv_create_spec.  */
-static void __attribute__ ((unused))
-gconv_destroy_spec (struct gconv_spec *conv_spec)
-{
-  free (conv_spec->fromcode);
-  free (conv_spec->tocode);
-  return;
-}
-
-
 /* This function copies in-order, characters from the source 's' that are
    either alpha-numeric or one in one of these: "_-.,:/" - into the destination
    'wp' while dropping all other characters.  In the process, it converts all
diff --git a/iconv/gconv_int.h b/iconv/gconv_int.h
index e86938dae7..f721ce30ff 100644
--- a/iconv/gconv_int.h
+++ b/iconv/gconv_int.h
@@ -152,6 +152,27 @@ extern int __gconv_open (struct gconv_spec *conv_spec,
                          __gconv_t *handle, int flags);
 libc_hidden_proto (__gconv_open)
 
+/* This function accepts the charset names of the source and destination of the
+   conversion and populates *conv_spec with an equivalent conversion
+   specification that may later be used by __gconv_open.  The charset names
+   might contain options in the form of suffixes that alter the conversion,
+   e.g. "ISO-10646/UTF-8/TRANSLIT".  It processes the charset names, ignoring
+   and truncating any suffix options in fromcode, and processing and truncating
+   any suffix options in tocode.  Supported suffix options ("TRANSLIT" or
+   "IGNORE") when found in tocode lead to the corresponding flag in *conv_spec
+   to be set to true.  Unrecognized suffix options are silently discarded.  If
+   the function succeeds, it returns conv_spec back to the caller.  It returns
+   NULL upon failure.  */
+extern struct gconv_spec *
+__gconv_create_spec (struct gconv_spec *conv_spec, const char *fromcode,
+                     const char *tocode);
+libc_hidden_proto (__gconv_create_spec)
+
+/* This function frees all heap memory allocated by __gconv_create_spec.  */
+extern void
+__gconv_destroy_spec (struct gconv_spec *conv_spec);
+libc_hidden_proto (__gconv_destroy_spec)
+
 /* Free resources associated with transformation descriptor CD.  */
 extern int __gconv_close (__gconv_t cd)
      attribute_hidden;
diff --git a/iconv/iconv_open.c b/iconv/iconv_open.c
index dd54bc12e0..5b30055c04 100644
--- a/iconv/iconv_open.c
+++ b/iconv/iconv_open.c
@@ -39,7 +39,7 @@ iconv_open (const char *tocode, const char *fromcode)
 
   int res = __gconv_open (&conv_spec, &cd, 0);
 
-  gconv_destroy_spec (&conv_spec);
+  __gconv_destroy_spec (&conv_spec);
 
   if (__builtin_expect (res, __GCONV_OK) != __GCONV_OK)
     {
diff --git a/iconv/iconv_prog.c b/iconv/iconv_prog.c
index b4334faa57..d59979759c 100644
--- a/iconv/iconv_prog.c
+++ b/iconv/iconv_prog.c
@@ -184,7 +184,7 @@ main (int argc, char *argv[])
       /* Let's see whether we have these coded character sets.  */
       res = __gconv_open (&conv_spec, &cd, 0);
 
-      gconv_destroy_spec (&conv_spec);
+      __gconv_destroy_spec (&conv_spec);
 
       if (res != __GCONV_OK)
 	{
diff --git a/intl/dcigettext.c b/intl/dcigettext.c
index 2e7c662bc7..bd332e71da 100644
--- a/intl/dcigettext.c
+++ b/intl/dcigettext.c
@@ -1120,15 +1120,18 @@ _nl_find_msg (struct loaded_l10nfile *domain_file,
 
 # ifdef _LIBC
 
-		      struct gconv_spec conv_spec
-		        = { .fromcode = norm_add_slashes (charset, ""),
-		            .tocode = norm_add_slashes (outcharset, ""),
-		            /* We always want to use transliteration.  */
-		            .translit = true,
-		            .ignore = false
-		          };
+		      struct gconv_spec conv_spec;
+
+                      __gconv_create_spec (&conv_spec, charset, outcharset);
+
+		      /* We always want to use transliteration.  */
+                      conv_spec.translit = true;
+
 		      int r = __gconv_open (&conv_spec, &convd->conv,
 		                            GCONV_AVOID_NOCONV);
+
+                      __gconv_destroy_spec (&conv_spec);
+
 		      if (__builtin_expect (r != __GCONV_OK, 0))
 			{
 			  /* If the output encoding is the same there is
diff --git a/intl/tst-codeset.c b/intl/tst-codeset.c
index fd70432eca..e9f6e5e09f 100644
--- a/intl/tst-codeset.c
+++ b/intl/tst-codeset.c
@@ -22,13 +22,11 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <support/check.h>
 
 static int
 do_test (void)
 {
-  char *s;
-  int result = 0;
-
   unsetenv ("LANGUAGE");
   unsetenv ("OUTPUT_CHARSET");
   setlocale (LC_ALL, "de_DE.ISO-8859-1");
@@ -36,25 +34,21 @@ do_test (void)
   bindtextdomain ("codeset", OBJPFX "domaindir");
 
   /* Here we expect output in ISO-8859-1.  */
-  s = gettext ("cheese");
-  if (strcmp (s, "K\344se"))
-    {
-      printf ("call 1 returned: %s\n", s);
-      result = 1;
-    }
+  TEST_COMPARE_STRING (gettext ("cheese"), "K\344se");
 
+  /* Here we expect output in UTF-8.  */
   bind_textdomain_codeset ("codeset", "UTF-8");
+  TEST_COMPARE_STRING (gettext ("cheese"), "K\303\244se");
 
-  /* Here we expect output in UTF-8.  */
-  s = gettext ("cheese");
-  if (strcmp (s, "K\303\244se"))
-    {
-      printf ("call 2 returned: %s\n", s);
-      result = 1;
-    }
-
-  return result;
+  /* `a with umlaut' is transliterated to `ae'.  */
+  bind_textdomain_codeset ("codeset", "ASCII//TRANSLIT");
+  TEST_COMPARE_STRING (gettext ("cheese"), "Kaese");
+
+  /* Transliteration also works by default even if not set.  */
+  bind_textdomain_codeset ("codeset", "ASCII");
+  TEST_COMPARE_STRING (gettext ("cheese"), "Kaese");
+
+  return 0;
 }
 
-#define TEST_FUNCTION do_test ()
-#include "../test-skeleton.c"
+#include <support/test-driver.c>
diff --git a/stdio-common/Makefile b/stdio-common/Makefile
index 8475fd1f09..eff0c98d82 100644
--- a/stdio-common/Makefile
+++ b/stdio-common/Makefile
@@ -69,7 +69,8 @@ tests := tstscanf test_rdwr test-popen tstgetln test-fseek \
 	 tst-printf-bz25691 \
 	 tst-vfprintf-width-prec-alloc \
 	 tst-printf-fp-free \
-	 tst-printf-fp-leak
+	 tst-printf-fp-leak \
+	 test-strerr
 
 
 test-srcs = tst-unbputc tst-printf tst-printfsz-islongdouble
diff --git a/stdio-common/errlist.c b/stdio-common/errlist.c
index d15f13a22a..2ecf121674 100644
--- a/stdio-common/errlist.c
+++ b/stdio-common/errlist.c
@@ -20,9 +20,13 @@
 #include <libintl.h>
 #include <array_length.h>
 
+#ifndef ERR_MAP
+# define ERR_MAP(n) n
+#endif
+
 const char *const _sys_errlist_internal[] =
   {
-#define _S(n, str)         [n] = str,
+#define _S(n, str)         [ERR_MAP(n)] = str,
 #include <errlist.h>
 #undef _S
   };
@@ -41,20 +45,21 @@ static const union sys_errname_t
   {
 #define MSGSTRFIELD1(line) str##line
 #define MSGSTRFIELD(line)  MSGSTRFIELD1(line)
-#define _S(n, str)         char MSGSTRFIELD(__LINE__)[sizeof(str)];
+#define _S(n, str)         char MSGSTRFIELD(__LINE__)[sizeof(#n)];
 #include <errlist.h>
 #undef _S
   };
   char str[0];
 } _sys_errname = { {
-#define _S(n, s) s,
+#define _S(n, s) #n,
 #include <errlist.h>
 #undef _S
 } };
 
 static const unsigned short _sys_errnameidx[] =
 {
-#define _S(n, s) [n] = offsetof(union sys_errname_t, MSGSTRFIELD(__LINE__)),
+#define _S(n, s) \
+  [ERR_MAP(n)] = offsetof(union sys_errname_t, MSGSTRFIELD(__LINE__)),
 #include <errlist.h>
 #undef _S
 };
diff --git a/stdio-common/test-strerr.c b/stdio-common/test-strerr.c
index fded208118..d77b81d507 100644
--- a/stdio-common/test-strerr.c
+++ b/stdio-common/test-strerr.c
@@ -18,46 +18,672 @@
 
 #include <string.h>
 #include <errno.h>
-#include <array_length.h>
 
 #include <support/support.h>
 #include <support/check.h>
 
-#define N_(name)      name
-
-static const char *const errlist[] =
-  {
-/* This file is auto-generated from errlist.def.  */
-#include <errlist.h>
-  };
-
-#define MSGSTR_T errname_t
-#define MSGSTR   errname
-#define MSGIDX   errnameidx
-#include <errlist-name.h>
-#undef MSGSTR
-#undef MSGIDX
-
 static int
 do_test (void)
 {
-  TEST_VERIFY (strerrordesc_np (-1) == NULL);
-  TEST_VERIFY (strerrordesc_np (array_length (errlist)) == NULL);
-  for (size_t i = 0; i < array_length (errlist); i++)
-    {
-      if (errlist[i] == NULL)
-        continue;
-      TEST_COMPARE_STRING (strerrordesc_np (i), errlist[i]);
-    }
+  TEST_COMPARE_STRING (strerrordesc_np (0), "Success");
+  TEST_COMPARE_STRING (strerrorname_np (0), "0");
 
-  TEST_VERIFY (strerrorname_np (-1) == NULL);
-  TEST_VERIFY (strerrorname_np (array_length (errlist)) == NULL);
-  for (size_t i = 0; i < array_length (errlist); i++)
-    {
-      if (errlist[i] == NULL)
-        continue;
-      TEST_COMPARE_STRING (strerrorname_np (i), errname.str + errnameidx[i]);
-    }
+#ifdef EPERM
+  TEST_COMPARE_STRING (strerrordesc_np (EPERM), "Operation not permitted");
+  TEST_COMPARE_STRING (strerrorname_np (EPERM), "EPERM");
+#endif
+#ifdef ENOENT
+  TEST_COMPARE_STRING (strerrordesc_np (ENOENT),
+		       "No such file or directory");
+  TEST_COMPARE_STRING (strerrorname_np (ENOENT), "ENOENT");
+#endif
+#ifdef ESRCH
+  TEST_COMPARE_STRING (strerrordesc_np (ESRCH), "No such process");
+  TEST_COMPARE_STRING (strerrorname_np (ESRCH), "ESRCH");
+#endif
+#ifdef EINTR
+  TEST_COMPARE_STRING (strerrordesc_np (EINTR), "Interrupted system call");
+  TEST_COMPARE_STRING (strerrorname_np (EINTR), "EINTR");
+#endif
+#ifdef EIO
+  TEST_COMPARE_STRING (strerrordesc_np (EIO), "Input/output error");
+  TEST_COMPARE_STRING (strerrorname_np (EIO), "EIO");
+#endif
+#ifdef ENXIO
+  TEST_COMPARE_STRING (strerrordesc_np (ENXIO), "No such device or address");
+  TEST_COMPARE_STRING (strerrorname_np (ENXIO), "ENXIO");
+#endif
+#ifdef E2BIG
+  TEST_COMPARE_STRING (strerrordesc_np (E2BIG), "Argument list too long");
+  TEST_COMPARE_STRING (strerrorname_np (E2BIG), "E2BIG");
+#endif
+#ifdef ENOEXEC
+  TEST_COMPARE_STRING (strerrordesc_np (ENOEXEC), "Exec format error");
+  TEST_COMPARE_STRING (strerrorname_np (ENOEXEC), "ENOEXEC");
+#endif
+#ifdef EBADF
+  TEST_COMPARE_STRING (strerrordesc_np (EBADF), "Bad file descriptor");
+  TEST_COMPARE_STRING (strerrorname_np (EBADF), "EBADF");
+#endif
+#ifdef ECHILD
+  TEST_COMPARE_STRING (strerrordesc_np (ECHILD), "No child processes");
+  TEST_COMPARE_STRING (strerrorname_np (ECHILD), "ECHILD");
+#endif
+#ifdef EDEADLK
+  TEST_COMPARE_STRING (strerrordesc_np (EDEADLK),
+		       "Resource deadlock avoided");
+  TEST_COMPARE_STRING (strerrorname_np (EDEADLK), "EDEADLK");
+#endif
+#ifdef ENOMEM
+  TEST_COMPARE_STRING (strerrordesc_np (ENOMEM), "Cannot allocate memory");
+  TEST_COMPARE_STRING (strerrorname_np (ENOMEM), "ENOMEM");
+#endif
+#ifdef EACCES
+  TEST_COMPARE_STRING (strerrordesc_np (EACCES), "Permission denied");
+  TEST_COMPARE_STRING (strerrorname_np (EACCES), "EACCES");
+#endif
+#ifdef EFAULT
+  TEST_COMPARE_STRING (strerrordesc_np (EFAULT), "Bad address");
+  TEST_COMPARE_STRING (strerrorname_np (EFAULT), "EFAULT");
+#endif
+#ifdef ENOTBLK
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTBLK), "Block device required");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTBLK), "ENOTBLK");
+#endif
+#ifdef EBUSY
+  TEST_COMPARE_STRING (strerrordesc_np (EBUSY), "Device or resource busy");
+  TEST_COMPARE_STRING (strerrorname_np (EBUSY), "EBUSY");
+#endif
+#ifdef EEXIST
+  TEST_COMPARE_STRING (strerrordesc_np (EEXIST), "File exists");
+  TEST_COMPARE_STRING (strerrorname_np (EEXIST), "EEXIST");
+#endif
+#ifdef EXDEV
+  TEST_COMPARE_STRING (strerrordesc_np (EXDEV), "Invalid cross-device link");
+  TEST_COMPARE_STRING (strerrorname_np (EXDEV), "EXDEV");
+#endif
+#ifdef ENODEV
+  TEST_COMPARE_STRING (strerrordesc_np (ENODEV), "No such device");
+  TEST_COMPARE_STRING (strerrorname_np (ENODEV), "ENODEV");
+#endif
+#ifdef ENOTDIR
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTDIR), "Not a directory");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTDIR), "ENOTDIR");
+#endif
+#ifdef EISDIR
+  TEST_COMPARE_STRING (strerrordesc_np (EISDIR), "Is a directory");
+  TEST_COMPARE_STRING (strerrorname_np (EISDIR), "EISDIR");
+#endif
+#ifdef EINVAL
+  TEST_COMPARE_STRING (strerrordesc_np (EINVAL), "Invalid argument");
+  TEST_COMPARE_STRING (strerrorname_np (EINVAL), "EINVAL");
+#endif
+#ifdef EMFILE
+  TEST_COMPARE_STRING (strerrordesc_np (EMFILE), "Too many open files");
+  TEST_COMPARE_STRING (strerrorname_np (EMFILE), "EMFILE");
+#endif
+#ifdef ENFILE
+  TEST_COMPARE_STRING (strerrordesc_np (ENFILE),
+		       "Too many open files in system");
+  TEST_COMPARE_STRING (strerrorname_np (ENFILE), "ENFILE");
+#endif
+#ifdef ENOTTY
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTTY),
+		       "Inappropriate ioctl for device");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTTY), "ENOTTY");
+#endif
+#ifdef ETXTBSY
+  TEST_COMPARE_STRING (strerrordesc_np (ETXTBSY), "Text file busy");
+  TEST_COMPARE_STRING (strerrorname_np (ETXTBSY), "ETXTBSY");
+#endif
+#ifdef EFBIG
+  TEST_COMPARE_STRING (strerrordesc_np (EFBIG), "File too large");
+  TEST_COMPARE_STRING (strerrorname_np (EFBIG), "EFBIG");
+#endif
+#ifdef ENOSPC
+  TEST_COMPARE_STRING (strerrordesc_np (ENOSPC), "No space left on device");
+  TEST_COMPARE_STRING (strerrorname_np (ENOSPC), "ENOSPC");
+#endif
+#ifdef ESPIPE
+  TEST_COMPARE_STRING (strerrordesc_np (ESPIPE), "Illegal seek");
+  TEST_COMPARE_STRING (strerrorname_np (ESPIPE), "ESPIPE");
+#endif
+#ifdef EROFS
+  TEST_COMPARE_STRING (strerrordesc_np (EROFS), "Read-only file system");
+  TEST_COMPARE_STRING (strerrorname_np (EROFS), "EROFS");
+#endif
+#ifdef EMLINK
+  TEST_COMPARE_STRING (strerrordesc_np (EMLINK), "Too many links");
+  TEST_COMPARE_STRING (strerrorname_np (EMLINK), "EMLINK");
+#endif
+#ifdef EPIPE
+  TEST_COMPARE_STRING (strerrordesc_np (EPIPE), "Broken pipe");
+  TEST_COMPARE_STRING (strerrorname_np (EPIPE), "EPIPE");
+#endif
+#ifdef EDOM
+  TEST_COMPARE_STRING (strerrordesc_np (EDOM),
+		       "Numerical argument out of domain");
+  TEST_COMPARE_STRING (strerrorname_np (EDOM), "EDOM");
+#endif
+#ifdef ERANGE
+  TEST_COMPARE_STRING (strerrordesc_np (ERANGE),
+		       "Numerical result out of range");
+  TEST_COMPARE_STRING (strerrorname_np (ERANGE), "ERANGE");
+#endif
+#ifdef EAGAIN
+  TEST_COMPARE_STRING (strerrordesc_np (EAGAIN),
+		       "Resource temporarily unavailable");
+  TEST_COMPARE_STRING (strerrorname_np (EAGAIN), "EAGAIN");
+#endif
+#ifdef EINPROGRESS
+  TEST_COMPARE_STRING (strerrordesc_np (EINPROGRESS),
+		       "Operation now in progress");
+  TEST_COMPARE_STRING (strerrorname_np (EINPROGRESS), "EINPROGRESS");
+#endif
+#ifdef EALREADY
+  TEST_COMPARE_STRING (strerrordesc_np (EALREADY),
+		       "Operation already in progress");
+  TEST_COMPARE_STRING (strerrorname_np (EALREADY), "EALREADY");
+#endif
+#ifdef ENOTSOCK
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTSOCK),
+		       "Socket operation on non-socket");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTSOCK), "ENOTSOCK");
+#endif
+#ifdef EMSGSIZE
+  TEST_COMPARE_STRING (strerrordesc_np (EMSGSIZE), "Message too long");
+  TEST_COMPARE_STRING (strerrorname_np (EMSGSIZE), "EMSGSIZE");
+#endif
+#ifdef EPROTOTYPE
+  TEST_COMPARE_STRING (strerrordesc_np (EPROTOTYPE),
+		       "Protocol wrong type for socket");
+  TEST_COMPARE_STRING (strerrorname_np (EPROTOTYPE), "EPROTOTYPE");
+#endif
+#ifdef ENOPROTOOPT
+  TEST_COMPARE_STRING (strerrordesc_np (ENOPROTOOPT),
+		       "Protocol not available");
+  TEST_COMPARE_STRING (strerrorname_np (ENOPROTOOPT), "ENOPROTOOPT");
+#endif
+#ifdef EPROTONOSUPPORT
+  TEST_COMPARE_STRING (strerrordesc_np (EPROTONOSUPPORT),
+		       "Protocol not supported");
+  TEST_COMPARE_STRING (strerrorname_np (EPROTONOSUPPORT), "EPROTONOSUPPORT");
+#endif
+#ifdef ESOCKTNOSUPPORT
+  TEST_COMPARE_STRING (strerrordesc_np (ESOCKTNOSUPPORT),
+		       "Socket type not supported");
+  TEST_COMPARE_STRING (strerrorname_np (ESOCKTNOSUPPORT), "ESOCKTNOSUPPORT");
+#endif
+#ifdef EOPNOTSUPP
+  TEST_COMPARE_STRING (strerrordesc_np (EOPNOTSUPP),
+		       "Operation not supported");
+  TEST_COMPARE_STRING (strerrorname_np (EOPNOTSUPP), "EOPNOTSUPP");
+#endif
+#ifdef EPFNOSUPPORT
+  TEST_COMPARE_STRING (strerrordesc_np (EPFNOSUPPORT),
+		       "Protocol family not supported");
+  TEST_COMPARE_STRING (strerrorname_np (EPFNOSUPPORT), "EPFNOSUPPORT");
+#endif
+#ifdef EAFNOSUPPORT
+  TEST_COMPARE_STRING (strerrordesc_np (EAFNOSUPPORT),
+		       "Address family not supported by protocol");
+  TEST_COMPARE_STRING (strerrorname_np (EAFNOSUPPORT), "EAFNOSUPPORT");
+#endif
+#ifdef EADDRINUSE
+  TEST_COMPARE_STRING (strerrordesc_np (EADDRINUSE),
+		       "Address already in use");
+  TEST_COMPARE_STRING (strerrorname_np (EADDRINUSE), "EADDRINUSE");
+#endif
+#ifdef EADDRNOTAVAIL
+  TEST_COMPARE_STRING (strerrordesc_np (EADDRNOTAVAIL),
+		       "Cannot assign requested address");
+  TEST_COMPARE_STRING (strerrorname_np (EADDRNOTAVAIL), "EADDRNOTAVAIL");
+#endif
+#ifdef ENETDOWN
+  TEST_COMPARE_STRING (strerrordesc_np (ENETDOWN), "Network is down");
+  TEST_COMPARE_STRING (strerrorname_np (ENETDOWN), "ENETDOWN");
+#endif
+#ifdef ENETUNREACH
+  TEST_COMPARE_STRING (strerrordesc_np (ENETUNREACH),
+		       "Network is unreachable");
+  TEST_COMPARE_STRING (strerrorname_np (ENETUNREACH), "ENETUNREACH");
+#endif
+#ifdef ENETRESET
+  TEST_COMPARE_STRING (strerrordesc_np (ENETRESET),
+		       "Network dropped connection on reset");
+  TEST_COMPARE_STRING (strerrorname_np (ENETRESET), "ENETRESET");
+#endif
+#ifdef ECONNABORTED
+  TEST_COMPARE_STRING (strerrordesc_np (ECONNABORTED),
+		       "Software caused connection abort");
+  TEST_COMPARE_STRING (strerrorname_np (ECONNABORTED), "ECONNABORTED");
+#endif
+#ifdef ECONNRESET
+  TEST_COMPARE_STRING (strerrordesc_np (ECONNRESET),
+		       "Connection reset by peer");
+  TEST_COMPARE_STRING (strerrorname_np (ECONNRESET), "ECONNRESET");
+#endif
+#ifdef ENOBUFS
+  TEST_COMPARE_STRING (strerrordesc_np (ENOBUFS),
+		       "No buffer space available");
+  TEST_COMPARE_STRING (strerrorname_np (ENOBUFS), "ENOBUFS");
+#endif
+#ifdef EISCONN
+  TEST_COMPARE_STRING (strerrordesc_np (EISCONN),
+		       "Transport endpoint is already connected");
+  TEST_COMPARE_STRING (strerrorname_np (EISCONN), "EISCONN");
+#endif
+#ifdef ENOTCONN
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTCONN),
+		       "Transport endpoint is not connected");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTCONN), "ENOTCONN");
+#endif
+#ifdef EDESTADDRREQ
+  TEST_COMPARE_STRING (strerrordesc_np (EDESTADDRREQ),
+		       "Destination address required");
+  TEST_COMPARE_STRING (strerrorname_np (EDESTADDRREQ), "EDESTADDRREQ");
+#endif
+#ifdef ESHUTDOWN
+  TEST_COMPARE_STRING (strerrordesc_np (ESHUTDOWN),
+		       "Cannot send after transport endpoint shutdown");
+  TEST_COMPARE_STRING (strerrorname_np (ESHUTDOWN), "ESHUTDOWN");
+#endif
+#ifdef ETOOMANYREFS
+  TEST_COMPARE_STRING (strerrordesc_np (ETOOMANYREFS),
+		       "Too many references: cannot splice");
+  TEST_COMPARE_STRING (strerrorname_np (ETOOMANYREFS), "ETOOMANYREFS");
+#endif
+#ifdef ETIMEDOUT
+  TEST_COMPARE_STRING (strerrordesc_np (ETIMEDOUT), "Connection timed out");
+  TEST_COMPARE_STRING (strerrorname_np (ETIMEDOUT), "ETIMEDOUT");
+#endif
+#ifdef ECONNREFUSED
+  TEST_COMPARE_STRING (strerrordesc_np (ECONNREFUSED), "Connection refused");
+  TEST_COMPARE_STRING (strerrorname_np (ECONNREFUSED), "ECONNREFUSED");
+#endif
+#ifdef ELOOP
+  TEST_COMPARE_STRING (strerrordesc_np (ELOOP),
+		       "Too many levels of symbolic links");
+  TEST_COMPARE_STRING (strerrorname_np (ELOOP), "ELOOP");
+#endif
+#ifdef ENAMETOOLONG
+  TEST_COMPARE_STRING (strerrordesc_np (ENAMETOOLONG), "File name too long");
+  TEST_COMPARE_STRING (strerrorname_np (ENAMETOOLONG), "ENAMETOOLONG");
+#endif
+#ifdef EHOSTDOWN
+  TEST_COMPARE_STRING (strerrordesc_np (EHOSTDOWN), "Host is down");
+  TEST_COMPARE_STRING (strerrorname_np (EHOSTDOWN), "EHOSTDOWN");
+#endif
+#ifdef EHOSTUNREACH
+  TEST_COMPARE_STRING (strerrordesc_np (EHOSTUNREACH), "No route to host");
+  TEST_COMPARE_STRING (strerrorname_np (EHOSTUNREACH), "EHOSTUNREACH");
+#endif
+#ifdef ENOTEMPTY
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTEMPTY), "Directory not empty");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTEMPTY), "ENOTEMPTY");
+#endif
+#ifdef EUSERS
+  TEST_COMPARE_STRING (strerrordesc_np (EUSERS), "Too many users");
+  TEST_COMPARE_STRING (strerrorname_np (EUSERS), "EUSERS");
+#endif
+#ifdef EDQUOT
+  TEST_COMPARE_STRING (strerrordesc_np (EDQUOT), "Disk quota exceeded");
+  TEST_COMPARE_STRING (strerrorname_np (EDQUOT), "EDQUOT");
+#endif
+#ifdef ESTALE
+  TEST_COMPARE_STRING (strerrordesc_np (ESTALE), "Stale file handle");
+  TEST_COMPARE_STRING (strerrorname_np (ESTALE), "ESTALE");
+#endif
+#ifdef EREMOTE
+  TEST_COMPARE_STRING (strerrordesc_np (EREMOTE), "Object is remote");
+  TEST_COMPARE_STRING (strerrorname_np (EREMOTE), "EREMOTE");
+#endif
+#ifdef ENOLCK
+  TEST_COMPARE_STRING (strerrordesc_np (ENOLCK), "No locks available");
+  TEST_COMPARE_STRING (strerrorname_np (ENOLCK), "ENOLCK");
+#endif
+#ifdef ENOSYS
+  TEST_COMPARE_STRING (strerrordesc_np (ENOSYS), "Function not implemented");
+  TEST_COMPARE_STRING (strerrorname_np (ENOSYS), "ENOSYS");
+#endif
+#ifdef EILSEQ
+  TEST_COMPARE_STRING (strerrordesc_np (EILSEQ),
+		       "Invalid or incomplete multibyte or wide character");
+  TEST_COMPARE_STRING (strerrorname_np (EILSEQ), "EILSEQ");
+#endif
+#ifdef EBADMSG
+  TEST_COMPARE_STRING (strerrordesc_np (EBADMSG), "Bad message");
+  TEST_COMPARE_STRING (strerrorname_np (EBADMSG), "EBADMSG");
+#endif
+#ifdef EIDRM
+  TEST_COMPARE_STRING (strerrordesc_np (EIDRM), "Identifier removed");
+  TEST_COMPARE_STRING (strerrorname_np (EIDRM), "EIDRM");
+#endif
+#ifdef EMULTIHOP
+  TEST_COMPARE_STRING (strerrordesc_np (EMULTIHOP), "Multihop attempted");
+  TEST_COMPARE_STRING (strerrorname_np (EMULTIHOP), "EMULTIHOP");
+#endif
+#ifdef ENODATA
+  TEST_COMPARE_STRING (strerrordesc_np (ENODATA), "No data available");
+  TEST_COMPARE_STRING (strerrorname_np (ENODATA), "ENODATA");
+#endif
+#ifdef ENOLINK
+  TEST_COMPARE_STRING (strerrordesc_np (ENOLINK), "Link has been severed");
+  TEST_COMPARE_STRING (strerrorname_np (ENOLINK), "ENOLINK");
+#endif
+#ifdef ENOMSG
+  TEST_COMPARE_STRING (strerrordesc_np (ENOMSG),
+		       "No message of desired type");
+  TEST_COMPARE_STRING (strerrorname_np (ENOMSG), "ENOMSG");
+#endif
+#ifdef ENOSR
+  TEST_COMPARE_STRING (strerrordesc_np (ENOSR), "Out of streams resources");
+  TEST_COMPARE_STRING (strerrorname_np (ENOSR), "ENOSR");
+#endif
+#ifdef ENOSTR
+  TEST_COMPARE_STRING (strerrordesc_np (ENOSTR), "Device not a stream");
+  TEST_COMPARE_STRING (strerrorname_np (ENOSTR), "ENOSTR");
+#endif
+#ifdef EOVERFLOW
+  TEST_COMPARE_STRING (strerrordesc_np (EOVERFLOW),
+		       "Value too large for defined data type");
+  TEST_COMPARE_STRING (strerrorname_np (EOVERFLOW), "EOVERFLOW");
+#endif
+#ifdef EPROTO
+  TEST_COMPARE_STRING (strerrordesc_np (EPROTO), "Protocol error");
+  TEST_COMPARE_STRING (strerrorname_np (EPROTO), "EPROTO");
+#endif
+#ifdef ETIME
+  TEST_COMPARE_STRING (strerrordesc_np (ETIME), "Timer expired");
+  TEST_COMPARE_STRING (strerrorname_np (ETIME), "ETIME");
+#endif
+#ifdef ECANCELED
+  TEST_COMPARE_STRING (strerrordesc_np (ECANCELED), "Operation canceled");
+  TEST_COMPARE_STRING (strerrorname_np (ECANCELED), "ECANCELED");
+#endif
+#ifdef EOWNERDEAD
+  TEST_COMPARE_STRING (strerrordesc_np (EOWNERDEAD), "Owner died");
+  TEST_COMPARE_STRING (strerrorname_np (EOWNERDEAD), "EOWNERDEAD");
+#endif
+#ifdef ENOTRECOVERABLE
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTRECOVERABLE),
+		       "State not recoverable");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTRECOVERABLE), "ENOTRECOVERABLE");
+#endif
+#ifdef ERESTART
+  TEST_COMPARE_STRING (strerrordesc_np (ERESTART),
+		       "Interrupted system call should be restarted");
+  TEST_COMPARE_STRING (strerrorname_np (ERESTART), "ERESTART");
+#endif
+#ifdef ECHRNG
+  TEST_COMPARE_STRING (strerrordesc_np (ECHRNG),
+		       "Channel number out of range");
+  TEST_COMPARE_STRING (strerrorname_np (ECHRNG), "ECHRNG");
+#endif
+#ifdef EL2NSYNC
+  TEST_COMPARE_STRING (strerrordesc_np (EL2NSYNC),
+		       "Level 2 not synchronized");
+  TEST_COMPARE_STRING (strerrorname_np (EL2NSYNC), "EL2NSYNC");
+#endif
+#ifdef EL3HLT
+  TEST_COMPARE_STRING (strerrordesc_np (EL3HLT), "Level 3 halted");
+  TEST_COMPARE_STRING (strerrorname_np (EL3HLT), "EL3HLT");
+#endif
+#ifdef EL3RST
+  TEST_COMPARE_STRING (strerrordesc_np (EL3RST), "Level 3 reset");
+  TEST_COMPARE_STRING (strerrorname_np (EL3RST), "EL3RST");
+#endif
+#ifdef ELNRNG
+  TEST_COMPARE_STRING (strerrordesc_np (ELNRNG), "Link number out of range");
+  TEST_COMPARE_STRING (strerrorname_np (ELNRNG), "ELNRNG");
+#endif
+#ifdef EUNATCH
+  TEST_COMPARE_STRING (strerrordesc_np (EUNATCH),
+		       "Protocol driver not attached");
+  TEST_COMPARE_STRING (strerrorname_np (EUNATCH), "EUNATCH");
+#endif
+#ifdef ENOCSI
+  TEST_COMPARE_STRING (strerrordesc_np (ENOCSI),
+		       "No CSI structure available");
+  TEST_COMPARE_STRING (strerrorname_np (ENOCSI), "ENOCSI");
+#endif
+#ifdef EL2HLT
+  TEST_COMPARE_STRING (strerrordesc_np (EL2HLT), "Level 2 halted");
+  TEST_COMPARE_STRING (strerrorname_np (EL2HLT), "EL2HLT");
+#endif
+#ifdef EBADE
+  TEST_COMPARE_STRING (strerrordesc_np (EBADE), "Invalid exchange");
+  TEST_COMPARE_STRING (strerrorname_np (EBADE), "EBADE");
+#endif
+#ifdef EBADR
+  TEST_COMPARE_STRING (strerrordesc_np (EBADR),
+		       "Invalid request descriptor");
+  TEST_COMPARE_STRING (strerrorname_np (EBADR), "EBADR");
+#endif
+#ifdef EXFULL
+  TEST_COMPARE_STRING (strerrordesc_np (EXFULL), "Exchange full");
+  TEST_COMPARE_STRING (strerrorname_np (EXFULL), "EXFULL");
+#endif
+#ifdef ENOANO
+  TEST_COMPARE_STRING (strerrordesc_np (ENOANO), "No anode");
+  TEST_COMPARE_STRING (strerrorname_np (ENOANO), "ENOANO");
+#endif
+#ifdef EBADRQC
+  TEST_COMPARE_STRING (strerrordesc_np (EBADRQC), "Invalid request code");
+  TEST_COMPARE_STRING (strerrorname_np (EBADRQC), "EBADRQC");
+#endif
+#ifdef EBADSLT
+  TEST_COMPARE_STRING (strerrordesc_np (EBADSLT), "Invalid slot");
+  TEST_COMPARE_STRING (strerrorname_np (EBADSLT), "EBADSLT");
+#endif
+#ifdef EBFONT
+  TEST_COMPARE_STRING (strerrordesc_np (EBFONT), "Bad font file format");
+  TEST_COMPARE_STRING (strerrorname_np (EBFONT), "EBFONT");
+#endif
+#ifdef ENONET
+  TEST_COMPARE_STRING (strerrordesc_np (ENONET),
+		       "Machine is not on the network");
+  TEST_COMPARE_STRING (strerrorname_np (ENONET), "ENONET");
+#endif
+#ifdef ENOPKG
+  TEST_COMPARE_STRING (strerrordesc_np (ENOPKG), "Package not installed");
+  TEST_COMPARE_STRING (strerrorname_np (ENOPKG), "ENOPKG");
+#endif
+#ifdef EADV
+  TEST_COMPARE_STRING (strerrordesc_np (EADV), "Advertise error");
+  TEST_COMPARE_STRING (strerrorname_np (EADV), "EADV");
+#endif
+#ifdef ESRMNT
+  TEST_COMPARE_STRING (strerrordesc_np (ESRMNT), "Srmount error");
+  TEST_COMPARE_STRING (strerrorname_np (ESRMNT), "ESRMNT");
+#endif
+#ifdef ECOMM
+  TEST_COMPARE_STRING (strerrordesc_np (ECOMM),
+		       "Communication error on send");
+  TEST_COMPARE_STRING (strerrorname_np (ECOMM), "ECOMM");
+#endif
+#ifdef EDOTDOT
+  TEST_COMPARE_STRING (strerrordesc_np (EDOTDOT), "RFS specific error");
+  TEST_COMPARE_STRING (strerrorname_np (EDOTDOT), "EDOTDOT");
+#endif
+#ifdef ENOTUNIQ
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTUNIQ),
+		       "Name not unique on network");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTUNIQ), "ENOTUNIQ");
+#endif
+#ifdef EBADFD
+  TEST_COMPARE_STRING (strerrordesc_np (EBADFD),
+		       "File descriptor in bad state");
+  TEST_COMPARE_STRING (strerrorname_np (EBADFD), "EBADFD");
+#endif
+#ifdef EREMCHG
+  TEST_COMPARE_STRING (strerrordesc_np (EREMCHG), "Remote address changed");
+  TEST_COMPARE_STRING (strerrorname_np (EREMCHG), "EREMCHG");
+#endif
+#ifdef ELIBACC
+  TEST_COMPARE_STRING (strerrordesc_np (ELIBACC),
+		       "Can not access a needed shared library");
+  TEST_COMPARE_STRING (strerrorname_np (ELIBACC), "ELIBACC");
+#endif
+#ifdef ELIBBAD
+  TEST_COMPARE_STRING (strerrordesc_np (ELIBBAD),
+		       "Accessing a corrupted shared library");
+  TEST_COMPARE_STRING (strerrorname_np (ELIBBAD), "ELIBBAD");
+#endif
+#ifdef ELIBSCN
+  TEST_COMPARE_STRING (strerrordesc_np (ELIBSCN),
+		       ".lib section in a.out corrupted");
+  TEST_COMPARE_STRING (strerrorname_np (ELIBSCN), "ELIBSCN");
+#endif
+#ifdef ELIBMAX
+  TEST_COMPARE_STRING (strerrordesc_np (ELIBMAX),
+		       "Attempting to link in too many shared libraries");
+  TEST_COMPARE_STRING (strerrorname_np (ELIBMAX), "ELIBMAX");
+#endif
+#ifdef ELIBEXEC
+  TEST_COMPARE_STRING (strerrordesc_np (ELIBEXEC),
+		       "Cannot exec a shared library directly");
+  TEST_COMPARE_STRING (strerrorname_np (ELIBEXEC), "ELIBEXEC");
+#endif
+#ifdef ESTRPIPE
+  TEST_COMPARE_STRING (strerrordesc_np (ESTRPIPE), "Streams pipe error");
+  TEST_COMPARE_STRING (strerrorname_np (ESTRPIPE), "ESTRPIPE");
+#endif
+#ifdef EUCLEAN
+  TEST_COMPARE_STRING (strerrordesc_np (EUCLEAN),
+		       "Structure needs cleaning");
+  TEST_COMPARE_STRING (strerrorname_np (EUCLEAN), "EUCLEAN");
+#endif
+#ifdef ENOTNAM
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTNAM),
+		       "Not a XENIX named type file");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTNAM), "ENOTNAM");
+#endif
+#ifdef ENAVAIL
+  TEST_COMPARE_STRING (strerrordesc_np (ENAVAIL),
+		       "No XENIX semaphores available");
+  TEST_COMPARE_STRING (strerrorname_np (ENAVAIL), "ENAVAIL");
+#endif
+#ifdef EISNAM
+  TEST_COMPARE_STRING (strerrordesc_np (EISNAM), "Is a named type file");
+  TEST_COMPARE_STRING (strerrorname_np (EISNAM), "EISNAM");
+#endif
+#ifdef EREMOTEIO
+  TEST_COMPARE_STRING (strerrordesc_np (EREMOTEIO), "Remote I/O error");
+  TEST_COMPARE_STRING (strerrorname_np (EREMOTEIO), "EREMOTEIO");
+#endif
+#ifdef ENOMEDIUM
+  TEST_COMPARE_STRING (strerrordesc_np (ENOMEDIUM), "No medium found");
+  TEST_COMPARE_STRING (strerrorname_np (ENOMEDIUM), "ENOMEDIUM");
+#endif
+#ifdef EMEDIUMTYPE
+  TEST_COMPARE_STRING (strerrordesc_np (EMEDIUMTYPE), "Wrong medium type");
+  TEST_COMPARE_STRING (strerrorname_np (EMEDIUMTYPE), "EMEDIUMTYPE");
+#endif
+#ifdef ENOKEY
+  TEST_COMPARE_STRING (strerrordesc_np (ENOKEY),
+		       "Required key not available");
+  TEST_COMPARE_STRING (strerrorname_np (ENOKEY), "ENOKEY");
+#endif
+#ifdef EKEYEXPIRED
+  TEST_COMPARE_STRING (strerrordesc_np (EKEYEXPIRED), "Key has expired");
+  TEST_COMPARE_STRING (strerrorname_np (EKEYEXPIRED), "EKEYEXPIRED");
+#endif
+#ifdef EKEYREVOKED
+  TEST_COMPARE_STRING (strerrordesc_np (EKEYREVOKED),
+		       "Key has been revoked");
+  TEST_COMPARE_STRING (strerrorname_np (EKEYREVOKED), "EKEYREVOKED");
+#endif
+#ifdef EKEYREJECTED
+  TEST_COMPARE_STRING (strerrordesc_np (EKEYREJECTED),
+		       "Key was rejected by service");
+  TEST_COMPARE_STRING (strerrorname_np (EKEYREJECTED), "EKEYREJECTED");
+#endif
+#ifdef ERFKILL
+  TEST_COMPARE_STRING (strerrordesc_np (ERFKILL),
+		       "Operation not possible due to RF-kill");
+  TEST_COMPARE_STRING (strerrorname_np (ERFKILL), "ERFKILL");
+#endif
+#ifdef EHWPOISON
+  TEST_COMPARE_STRING (strerrordesc_np (EHWPOISON),
+		       "Memory page has hardware error");
+  TEST_COMPARE_STRING (strerrorname_np (EHWPOISON), "EHWPOISON");
+#endif
+#ifdef EBADRPC
+  TEST_COMPARE_STRING (strerrordesc_np (EBADRPC), "RPC struct is bad");
+  TEST_COMPARE_STRING (strerrorname_np (EBADRPC), "EBADRPC");
+#endif
+#ifdef EFTYPE
+  TEST_COMPARE_STRING (strerrordesc_np (EFTYPE),
+		       "Inappropriate file type or format");
+  TEST_COMPARE_STRING (strerrorname_np (EFTYPE), "EFTYPE");
+#endif
+#ifdef EPROCUNAVAIL
+  TEST_COMPARE_STRING (strerrordesc_np (EPROCUNAVAIL),
+		       "RPC bad procedure for program");
+  TEST_COMPARE_STRING (strerrorname_np (EPROCUNAVAIL), "EPROCUNAVAIL");
+#endif
+#ifdef EAUTH
+  TEST_COMPARE_STRING (strerrordesc_np (EAUTH), "Authentication error");
+  TEST_COMPARE_STRING (strerrorname_np (EAUTH), "EAUTH");
+#endif
+#ifdef EDIED
+  TEST_COMPARE_STRING (strerrordesc_np (EDIED), "Translator died");
+  TEST_COMPARE_STRING (strerrorname_np (EDIED), "EDIED");
+#endif
+#ifdef ERPCMISMATCH
+  TEST_COMPARE_STRING (strerrordesc_np (ERPCMISMATCH), "RPC version wrong");
+  TEST_COMPARE_STRING (strerrorname_np (ERPCMISMATCH), "ERPCMISMATCH");
+#endif
+#ifdef EGREGIOUS
+  TEST_COMPARE_STRING (strerrordesc_np (EGREGIOUS),
+		       "You really blew it this time");
+  TEST_COMPARE_STRING (strerrorname_np (EGREGIOUS), "EGREGIOUS");
+#endif
+#ifdef EPROCLIM
+  TEST_COMPARE_STRING (strerrordesc_np (EPROCLIM), "Too many processes");
+  TEST_COMPARE_STRING (strerrorname_np (EPROCLIM), "EPROCLIM");
+#endif
+#ifdef EGRATUITOUS
+  TEST_COMPARE_STRING (strerrordesc_np (EGRATUITOUS), "Gratuitous error");
+  TEST_COMPARE_STRING (strerrorname_np (EGRATUITOUS), "EGRATUITOUS");
+#endif
+#if defined (ENOTSUP) && ENOTSUP != EOPNOTSUPP
+  TEST_COMPARE_STRING (strerrordesc_np (ENOTSUP), "Not supported");
+  TEST_COMPARE_STRING (strerrorname_np (ENOTSUP), "ENOTSUP");
+#endif
+#ifdef EPROGMISMATCH
+  TEST_COMPARE_STRING (strerrordesc_np (EPROGMISMATCH),
+		       "RPC program version wrong");
+  TEST_COMPARE_STRING (strerrorname_np (EPROGMISMATCH), "EPROGMISMATCH");
+#endif
+#ifdef EBACKGROUND
+  TEST_COMPARE_STRING (strerrordesc_np (EBACKGROUND),
+		       "Inappropriate operation for background process");
+  TEST_COMPARE_STRING (strerrorname_np (EBACKGROUND), "EBACKGROUND");
+#endif
+#ifdef EIEIO
+  TEST_COMPARE_STRING (strerrordesc_np (EIEIO), "Computer bought the farm");
+  TEST_COMPARE_STRING (strerrorname_np (EIEIO), "EIEIO");
+#endif
+#if defined (EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
+  TEST_COMPARE_STRING (strerrordesc_np (EWOULDBLOCK),
+		       "Operation would block");
+  TEST_COMPARE_STRING (strerrorname_np (EWOULDBLOCK), "EWOULDBLOCK");
+#endif
+#ifdef ENEEDAUTH
+  TEST_COMPARE_STRING (strerrordesc_np (ENEEDAUTH), "Need authenticator");
+  TEST_COMPARE_STRING (strerrorname_np (ENEEDAUTH), "ENEEDAUTH");
+#endif
+#ifdef ED
+  TEST_COMPARE_STRING (strerrordesc_np (ED), "?");
+  TEST_COMPARE_STRING (strerrorname_np (ED), "ED");
+#endif
+#ifdef EPROGUNAVAIL
+  TEST_COMPARE_STRING (strerrordesc_np (EPROGUNAVAIL),
+		       "RPC program not available");
+  TEST_COMPARE_STRING (strerrorname_np (EPROGUNAVAIL), "EPROGUNAVAIL");
+#endif
 
   return 0;
 }
diff --git a/sysdeps/aarch64/multiarch/memcpy.c b/sysdeps/aarch64/multiarch/memcpy.c
index 7cf5f033e8..799d60c98c 100644
--- a/sysdeps/aarch64/multiarch/memcpy.c
+++ b/sysdeps/aarch64/multiarch/memcpy.c
@@ -41,7 +41,8 @@ libc_ifunc (__libc_memcpy,
 		? __memcpy_falkor
 		: (IS_THUNDERX2 (midr) || IS_THUNDERX2PA (midr)
 		  ? __memcpy_thunderx2
-		  : (IS_NEOVERSE_N1 (midr)
+		  : (IS_NEOVERSE_N1 (midr) || IS_NEOVERSE_N2 (midr)
+		     || IS_NEOVERSE_V1 (midr)
 		     ? __memcpy_simd
 		     : __memcpy_generic)))));
 
diff --git a/sysdeps/aarch64/multiarch/memcpy_advsimd.S b/sysdeps/aarch64/multiarch/memcpy_advsimd.S
index d4ba747777..48bb6d7ca4 100644
--- a/sysdeps/aarch64/multiarch/memcpy_advsimd.S
+++ b/sysdeps/aarch64/multiarch/memcpy_advsimd.S
@@ -223,12 +223,13 @@ L(copy_long_backwards):
 	b.ls	L(copy64_from_start)
 
 L(loop64_backwards):
-	stp	A_q, B_q, [dstend, -32]
+	str	B_q, [dstend, -16]
+	str	A_q, [dstend, -32]
 	ldp	A_q, B_q, [srcend, -96]
-	stp	C_q, D_q, [dstend, -64]
+	str	D_q, [dstend, -48]
+	str	C_q, [dstend, -64]!
 	ldp	C_q, D_q, [srcend, -128]
 	sub	srcend, srcend, 64
-	sub	dstend, dstend, 64
 	subs	count, count, 64
 	b.hi	L(loop64_backwards)
 
diff --git a/sysdeps/aarch64/multiarch/memmove.c b/sysdeps/aarch64/multiarch/memmove.c
index ad10aa8ac6..46a4cb3a54 100644
--- a/sysdeps/aarch64/multiarch/memmove.c
+++ b/sysdeps/aarch64/multiarch/memmove.c
@@ -41,7 +41,8 @@ libc_ifunc (__libc_memmove,
 		? __memmove_falkor
 		: (IS_THUNDERX2 (midr) || IS_THUNDERX2PA (midr)
 		  ? __memmove_thunderx2
-		  : (IS_NEOVERSE_N1 (midr)
+		  : (IS_NEOVERSE_N1 (midr) || IS_NEOVERSE_N2 (midr)
+		     || IS_NEOVERSE_V1 (midr)
 		     ? __memmove_simd
 		     : __memmove_generic)))));
 
diff --git a/sysdeps/gnu/errlist.h b/sysdeps/gnu/errlist.h
index 5d11ed723d..6329e5f393 100644
--- a/sysdeps/gnu/errlist.h
+++ b/sysdeps/gnu/errlist.h
@@ -1,24 +1,21 @@
-#ifndef ERR_MAP
-#define ERR_MAP(value) value
-#endif
-_S(ERR_MAP(0), N_("Success"))
+_S(0, N_("Success"))
 #ifdef EPERM
 /*
 TRANS Only the owner of the file (or other resource)
 TRANS or processes with special privileges can perform the operation. */
-_S(ERR_MAP(EPERM), N_("Operation not permitted"))
+_S(EPERM, N_("Operation not permitted"))
 #endif
 #ifdef ENOENT
 /*
 TRANS This is a ``file doesn't exist'' error
 TRANS for ordinary files that are referenced in contexts where they are
 TRANS expected to already exist. */
-_S(ERR_MAP(ENOENT), N_("No such file or directory"))
+_S(ENOENT, N_("No such file or directory"))
 #endif
 #ifdef ESRCH
 /*
 TRANS No process matches the specified process ID. */
-_S(ERR_MAP(ESRCH), N_("No such process"))
+_S(ESRCH, N_("No such process"))
 #endif
 #ifdef EINTR
 /*
@@ -29,12 +26,12 @@ TRANS
 TRANS You can choose to have functions resume after a signal that is handled,
 TRANS rather than failing with @code{EINTR}; see @ref{Interrupted
 TRANS Primitives}. */
-_S(ERR_MAP(EINTR), N_("Interrupted system call"))
+_S(EINTR, N_("Interrupted system call"))
 #endif
 #ifdef EIO
 /*
 TRANS Usually used for physical read or write errors. */
-_S(ERR_MAP(EIO), N_("Input/output error"))
+_S(EIO, N_("Input/output error"))
 #endif
 #ifdef ENXIO
 /*
@@ -43,7 +40,7 @@ TRANS represented by a file you specified, and it couldn't find the device.
 TRANS This can mean that the device file was installed incorrectly, or that
 TRANS the physical device is missing or not correctly attached to the
 TRANS computer. */
-_S(ERR_MAP(ENXIO), N_("No such device or address"))
+_S(ENXIO, N_("No such device or address"))
 #endif
 #ifdef E2BIG
 /*
@@ -51,27 +48,27 @@ TRANS Used when the arguments passed to a new program
 TRANS being executed with one of the @code{exec} functions (@pxref{Executing a
 TRANS File}) occupy too much memory space.  This condition never arises on
 TRANS @gnuhurdsystems{}. */
-_S(ERR_MAP(E2BIG), N_("Argument list too long"))
+_S(E2BIG, N_("Argument list too long"))
 #endif
 #ifdef ENOEXEC
 /*
 TRANS Invalid executable file format.  This condition is detected by the
 TRANS @code{exec} functions; see @ref{Executing a File}. */
-_S(ERR_MAP(ENOEXEC), N_("Exec format error"))
+_S(ENOEXEC, N_("Exec format error"))
 #endif
 #ifdef EBADF
 /*
 TRANS For example, I/O on a descriptor that has been
 TRANS closed or reading from a descriptor open only for writing (or vice
 TRANS versa). */
-_S(ERR_MAP(EBADF), N_("Bad file descriptor"))
+_S(EBADF, N_("Bad file descriptor"))
 #endif
 #ifdef ECHILD
 /*
 TRANS This error happens on operations that are
 TRANS supposed to manipulate child processes, when there aren't any processes
 TRANS to manipulate. */
-_S(ERR_MAP(ECHILD), N_("No child processes"))
+_S(ECHILD, N_("No child processes"))
 #endif
 #ifdef EDEADLK
 /*
@@ -79,74 +76,74 @@ TRANS Allocating a system resource would have resulted in a
 TRANS deadlock situation.  The system does not guarantee that it will notice
 TRANS all such situations.  This error means you got lucky and the system
 TRANS noticed; it might just hang.  @xref{File Locks}, for an example. */
-_S(ERR_MAP(EDEADLK), N_("Resource deadlock avoided"))
+_S(EDEADLK, N_("Resource deadlock avoided"))
 #endif
 #ifdef ENOMEM
 /*
 TRANS The system cannot allocate more virtual memory
 TRANS because its capacity is full. */
-_S(ERR_MAP(ENOMEM), N_("Cannot allocate memory"))
+_S(ENOMEM, N_("Cannot allocate memory"))
 #endif
 #ifdef EACCES
 /*
 TRANS The file permissions do not allow the attempted operation. */
-_S(ERR_MAP(EACCES), N_("Permission denied"))
+_S(EACCES, N_("Permission denied"))
 #endif
 #ifdef EFAULT
 /*
 TRANS An invalid pointer was detected.
 TRANS On @gnuhurdsystems{}, this error never happens; you get a signal instead. */
-_S(ERR_MAP(EFAULT), N_("Bad address"))
+_S(EFAULT, N_("Bad address"))
 #endif
 #ifdef ENOTBLK
 /*
 TRANS A file that isn't a block special file was given in a situation that
 TRANS requires one.  For example, trying to mount an ordinary file as a file
 TRANS system in Unix gives this error. */
-_S(ERR_MAP(ENOTBLK), N_("Block device required"))
+_S(ENOTBLK, N_("Block device required"))
 #endif
 #ifdef EBUSY
 /*
 TRANS A system resource that can't be shared is already in use.
 TRANS For example, if you try to delete a file that is the root of a currently
 TRANS mounted filesystem, you get this error. */
-_S(ERR_MAP(EBUSY), N_("Device or resource busy"))
+_S(EBUSY, N_("Device or resource busy"))
 #endif
 #ifdef EEXIST
 /*
 TRANS An existing file was specified in a context where it only
 TRANS makes sense to specify a new file. */
-_S(ERR_MAP(EEXIST), N_("File exists"))
+_S(EEXIST, N_("File exists"))
 #endif
 #ifdef EXDEV
 /*
 TRANS An attempt to make an improper link across file systems was detected.
 TRANS This happens not only when you use @code{link} (@pxref{Hard Links}) but
 TRANS also when you rename a file with @code{rename} (@pxref{Renaming Files}). */
-_S(ERR_MAP(EXDEV), N_("Invalid cross-device link"))
+_S(EXDEV, N_("Invalid cross-device link"))
 #endif
 #ifdef ENODEV
 /*
 TRANS The wrong type of device was given to a function that expects a
 TRANS particular sort of device. */
-_S(ERR_MAP(ENODEV), N_("No such device"))
+_S(ENODEV, N_("No such device"))
 #endif
 #ifdef ENOTDIR
 /*
 TRANS A file that isn't a directory was specified when a directory is required. */
-_S(ERR_MAP(ENOTDIR), N_("Not a directory"))
+_S(ENOTDIR, N_("Not a directory"))
 #endif
 #ifdef EISDIR
 /*
 TRANS You cannot open a directory for writing,
 TRANS or create or remove hard links to it. */
-_S(ERR_MAP(EISDIR), N_("Is a directory"))
+_S(EISDIR, N_("Is a directory"))
 #endif
 #ifdef EINVAL
 /*
 TRANS This is used to indicate various kinds of problems
 TRANS with passing the wrong argument to a library function. */
-_S(ERR_MAP(EINVAL), N_("Invalid argument"))
+_S(EINVAL, N_("Invalid argument"))
 #endif
 #ifdef EMFILE
 /*
@@ -157,20 +154,20 @@ TRANS In BSD and GNU, the number of open files is controlled by a resource
 TRANS limit that can usually be increased.  If you get this error, you might
 TRANS want to increase the @code{RLIMIT_NOFILE} limit or make it unlimited;
 TRANS @pxref{Limits on Resources}. */
-_S(ERR_MAP(EMFILE), N_("Too many open files"))
+_S(EMFILE, N_("Too many open files"))
 #endif
 #ifdef ENFILE
 /*
 TRANS There are too many distinct file openings in the entire system.  Note
 TRANS that any number of linked channels count as just one file opening; see
 TRANS @ref{Linked Channels}.  This error never occurs on @gnuhurdsystems{}. */
-_S(ERR_MAP(ENFILE), N_("Too many open files in system"))
+_S(ENFILE, N_("Too many open files in system"))
 #endif
 #ifdef ENOTTY
 /*
 TRANS Inappropriate I/O control operation, such as trying to set terminal
 TRANS modes on an ordinary file. */
-_S(ERR_MAP(ENOTTY), N_("Inappropriate ioctl for device"))
+_S(ENOTTY, N_("Inappropriate ioctl for device"))
 #endif
 #ifdef ETXTBSY
 /*
@@ -179,35 +176,35 @@ TRANS write to a file that is currently being executed.  Often using a
 TRANS debugger to run a program is considered having it open for writing and
 TRANS will cause this error.  (The name stands for ``text file busy''.)  This
 TRANS is not an error on @gnuhurdsystems{}; the text is copied as necessary. */
-_S(ERR_MAP(ETXTBSY), N_("Text file busy"))
+_S(ETXTBSY, N_("Text file busy"))
 #endif
 #ifdef EFBIG
 /*
 TRANS The size of a file would be larger than allowed by the system. */
-_S(ERR_MAP(EFBIG), N_("File too large"))
+_S(EFBIG, N_("File too large"))
 #endif
 #ifdef ENOSPC
 /*
 TRANS Write operation on a file failed because the
 TRANS disk is full. */
-_S(ERR_MAP(ENOSPC), N_("No space left on device"))
+_S(ENOSPC, N_("No space left on device"))
 #endif
 #ifdef ESPIPE
 /*
 TRANS Invalid seek operation (such as on a pipe). */
-_S(ERR_MAP(ESPIPE), N_("Illegal seek"))
+_S(ESPIPE, N_("Illegal seek"))
 #endif
 #ifdef EROFS
 /*
 TRANS An attempt was made to modify something on a read-only file system. */
-_S(ERR_MAP(EROFS), N_("Read-only file system"))
+_S(EROFS, N_("Read-only file system"))
 #endif
 #ifdef EMLINK
 /*
 TRANS The link count of a single file would become too large.
 TRANS @code{rename} can cause this error if the file being renamed already has
 TRANS as many links as it can take (@pxref{Renaming Files}). */
-_S(ERR_MAP(EMLINK), N_("Too many links"))
+_S(EMLINK, N_("Too many links"))
 #endif
 #ifdef EPIPE
 /*
@@ -216,19 +213,19 @@ TRANS Every library function that returns this error code also generates a
 TRANS @code{SIGPIPE} signal; this signal terminates the program if not handled
 TRANS or blocked.  Thus, your program will never actually see @code{EPIPE}
 TRANS unless it has handled or blocked @code{SIGPIPE}. */
-_S(ERR_MAP(EPIPE), N_("Broken pipe"))
+_S(EPIPE, N_("Broken pipe"))
 #endif
 #ifdef EDOM
 /*
 TRANS Used by mathematical functions when an argument value does
 TRANS not fall into the domain over which the function is defined. */
-_S(ERR_MAP(EDOM), N_("Numerical argument out of domain"))
+_S(EDOM, N_("Numerical argument out of domain"))
 #endif
 #ifdef ERANGE
 /*
 TRANS Used by mathematical functions when the result value is
 TRANS not representable because of overflow or underflow. */
-_S(ERR_MAP(ERANGE), N_("Numerical result out of range"))
+_S(ERANGE, N_("Numerical result out of range"))
 #endif
 #ifdef EAGAIN
 /*
@@ -261,7 +258,7 @@ TRANS Such shortages are usually fairly serious and affect the whole system,
 TRANS so usually an interactive program should report the error to the user
 TRANS and return to its command loop.
 TRANS @end itemize */
-_S(ERR_MAP(EAGAIN), N_("Resource temporarily unavailable"))
+_S(EAGAIN, N_("Resource temporarily unavailable"))
 #endif
 #ifdef EINPROGRESS
 /*
@@ -273,47 +270,47 @@ TRANS the operation has begun and will take some time.  Attempts to manipulate
 TRANS the object before the call completes return @code{EALREADY}.  You can
 TRANS use the @code{select} function to find out when the pending operation
 TRANS has completed; @pxref{Waiting for I/O}. */
-_S(ERR_MAP(EINPROGRESS), N_("Operation now in progress"))
+_S(EINPROGRESS, N_("Operation now in progress"))
 #endif
 #ifdef EALREADY
 /*
 TRANS An operation is already in progress on an object that has non-blocking
 TRANS mode selected. */
-_S(ERR_MAP(EALREADY), N_("Operation already in progress"))
+_S(EALREADY, N_("Operation already in progress"))
 #endif
 #ifdef ENOTSOCK
 /*
 TRANS A file that isn't a socket was specified when a socket is required. */
-_S(ERR_MAP(ENOTSOCK), N_("Socket operation on non-socket"))
+_S(ENOTSOCK, N_("Socket operation on non-socket"))
 #endif
 #ifdef EMSGSIZE
 /*
 TRANS The size of a message sent on a socket was larger than the supported
 TRANS maximum size. */
-_S(ERR_MAP(EMSGSIZE), N_("Message too long"))
+_S(EMSGSIZE, N_("Message too long"))
 #endif
 #ifdef EPROTOTYPE
 /*
 TRANS The socket type does not support the requested communications protocol. */
-_S(ERR_MAP(EPROTOTYPE), N_("Protocol wrong type for socket"))
+_S(EPROTOTYPE, N_("Protocol wrong type for socket"))
 #endif
 #ifdef ENOPROTOOPT
 /*
 TRANS You specified a socket option that doesn't make sense for the
 TRANS particular protocol being used by the socket.  @xref{Socket Options}. */
-_S(ERR_MAP(ENOPROTOOPT), N_("Protocol not available"))
+_S(ENOPROTOOPT, N_("Protocol not available"))
 #endif
 #ifdef EPROTONOSUPPORT
 /*
 TRANS The socket domain does not support the requested communications protocol
 TRANS (perhaps because the requested protocol is completely invalid).
 TRANS @xref{Creating a Socket}. */
-_S(ERR_MAP(EPROTONOSUPPORT), N_("Protocol not supported"))
+_S(EPROTONOSUPPORT, N_("Protocol not supported"))
 #endif
 #ifdef ESOCKTNOSUPPORT
 /*
 TRANS The socket type is not supported. */
-_S(ERR_MAP(ESOCKTNOSUPPORT), N_("Socket type not supported"))
+_S(ESOCKTNOSUPPORT, N_("Socket type not supported"))
 #endif
 #ifdef EOPNOTSUPP
 /*
@@ -323,71 +320,71 @@ TRANS implemented for all communications protocols.  On @gnuhurdsystems{}, this
 TRANS error can happen for many calls when the object does not support the
 TRANS particular operation; it is a generic indication that the server knows
 TRANS nothing to do for that call. */
-_S(ERR_MAP(EOPNOTSUPP), N_("Operation not supported"))
+_S(EOPNOTSUPP, N_("Operation not supported"))
 #endif
 #ifdef EPFNOSUPPORT
 /*
 TRANS The socket communications protocol family you requested is not supported. */
-_S(ERR_MAP(EPFNOSUPPORT), N_("Protocol family not supported"))
+_S(EPFNOSUPPORT, N_("Protocol family not supported"))
 #endif
 #ifdef EAFNOSUPPORT
 /*
 TRANS The address family specified for a socket is not supported; it is
 TRANS inconsistent with the protocol being used on the socket.  @xref{Sockets}. */
-_S(ERR_MAP(EAFNOSUPPORT), N_("Address family not supported by protocol"))
+_S(EAFNOSUPPORT, N_("Address family not supported by protocol"))
 #endif
 #ifdef EADDRINUSE
 /*
 TRANS The requested socket address is already in use.  @xref{Socket Addresses}. */
-_S(ERR_MAP(EADDRINUSE), N_("Address already in use"))
+_S(EADDRINUSE, N_("Address already in use"))
 #endif
 #ifdef EADDRNOTAVAIL
 /*
 TRANS The requested socket address is not available; for example, you tried
 TRANS to give a socket a name that doesn't match the local host name.
 TRANS @xref{Socket Addresses}. */
-_S(ERR_MAP(EADDRNOTAVAIL), N_("Cannot assign requested address"))
+_S(EADDRNOTAVAIL, N_("Cannot assign requested address"))
 #endif
 #ifdef ENETDOWN
 /*
 TRANS A socket operation failed because the network was down. */
-_S(ERR_MAP(ENETDOWN), N_("Network is down"))
+_S(ENETDOWN, N_("Network is down"))
 #endif
 #ifdef ENETUNREACH
 /*
 TRANS A socket operation failed because the subnet containing the remote host
 TRANS was unreachable. */
-_S(ERR_MAP(ENETUNREACH), N_("Network is unreachable"))
+_S(ENETUNREACH, N_("Network is unreachable"))
 #endif
 #ifdef ENETRESET
 /*
 TRANS A network connection was reset because the remote host crashed. */
-_S(ERR_MAP(ENETRESET), N_("Network dropped connection on reset"))
+_S(ENETRESET, N_("Network dropped connection on reset"))
 #endif
 #ifdef ECONNABORTED
 /*
 TRANS A network connection was aborted locally. */
-_S(ERR_MAP(ECONNABORTED), N_("Software caused connection abort"))
+_S(ECONNABORTED, N_("Software caused connection abort"))
 #endif
 #ifdef ECONNRESET
 /*
 TRANS A network connection was closed for reasons outside the control of the
 TRANS local host, such as by the remote machine rebooting or an unrecoverable
 TRANS protocol violation. */
-_S(ERR_MAP(ECONNRESET), N_("Connection reset by peer"))
+_S(ECONNRESET, N_("Connection reset by peer"))
 #endif
 #ifdef ENOBUFS
 /*
 TRANS The kernel's buffers for I/O operations are all in use.  In GNU, this
 TRANS error is always synonymous with @code{ENOMEM}; you may get one or the
 TRANS other from network operations. */
-_S(ERR_MAP(ENOBUFS), N_("No buffer space available"))
+_S(ENOBUFS, N_("No buffer space available"))
 #endif
 #ifdef EISCONN
 /*
 TRANS You tried to connect a socket that is already connected.
 TRANS @xref{Connecting}. */
-_S(ERR_MAP(EISCONN), N_("Transport endpoint is already connected"))
+_S(EISCONN, N_("Transport endpoint is already connected"))
 #endif
 #ifdef ENOTCONN
 /*
@@ -395,74 +392,74 @@ TRANS The socket is not connected to anything.  You get this error when you
 TRANS try to transmit data over a socket, without first specifying a
 TRANS destination for the data.  For a connectionless socket (for datagram
 TRANS protocols, such as UDP), you get @code{EDESTADDRREQ} instead. */
-_S(ERR_MAP(ENOTCONN), N_("Transport endpoint is not connected"))
+_S(ENOTCONN, N_("Transport endpoint is not connected"))
 #endif
 #ifdef EDESTADDRREQ
 /*
 TRANS No default destination address was set for the socket.  You get this
 TRANS error when you try to transmit data over a connectionless socket,
 TRANS without first specifying a destination for the data with @code{connect}. */
-_S(ERR_MAP(EDESTADDRREQ), N_("Destination address required"))
+_S(EDESTADDRREQ, N_("Destination address required"))
 #endif
 #ifdef ESHUTDOWN
 /*
 TRANS The socket has already been shut down. */
-_S(ERR_MAP(ESHUTDOWN), N_("Cannot send after transport endpoint shutdown"))
+_S(ESHUTDOWN, N_("Cannot send after transport endpoint shutdown"))
 #endif
 #ifdef ETOOMANYREFS
-_S(ERR_MAP(ETOOMANYREFS), N_("Too many references: cannot splice"))
+_S(ETOOMANYREFS, N_("Too many references: cannot splice"))
 #endif
 #ifdef ETIMEDOUT
 /*
 TRANS A socket operation with a specified timeout received no response during
 TRANS the timeout period. */
-_S(ERR_MAP(ETIMEDOUT), N_("Connection timed out"))
+_S(ETIMEDOUT, N_("Connection timed out"))
 #endif
 #ifdef ECONNREFUSED
 /*
 TRANS A remote host refused to allow the network connection (typically because
 TRANS it is not running the requested service). */
-_S(ERR_MAP(ECONNREFUSED), N_("Connection refused"))
+_S(ECONNREFUSED, N_("Connection refused"))
 #endif
 #ifdef ELOOP
 /*
 TRANS Too many levels of symbolic links were encountered in looking up a file name.
 TRANS This often indicates a cycle of symbolic links. */
-_S(ERR_MAP(ELOOP), N_("Too many levels of symbolic links"))
+_S(ELOOP, N_("Too many levels of symbolic links"))
 #endif
 #ifdef ENAMETOOLONG
 /*
 TRANS Filename too long (longer than @code{PATH_MAX}; @pxref{Limits for
 TRANS Files}) or host name too long (in @code{gethostname} or
 TRANS @code{sethostname}; @pxref{Host Identification}). */
-_S(ERR_MAP(ENAMETOOLONG), N_("File name too long"))
+_S(ENAMETOOLONG, N_("File name too long"))
 #endif
 #ifdef EHOSTDOWN
 /*
 TRANS The remote host for a requested network connection is down. */
-_S(ERR_MAP(EHOSTDOWN), N_("Host is down"))
+_S(EHOSTDOWN, N_("Host is down"))
 #endif
 /*
 TRANS The remote host for a requested network connection is not reachable. */
 #ifdef EHOSTUNREACH
-_S(ERR_MAP(EHOSTUNREACH), N_("No route to host"))
+_S(EHOSTUNREACH, N_("No route to host"))
 #endif
 #ifdef ENOTEMPTY
 /*
 TRANS Directory not empty, where an empty directory was expected.  Typically,
 TRANS this error occurs when you are trying to delete a directory. */
-_S(ERR_MAP(ENOTEMPTY), N_("Directory not empty"))
+_S(ENOTEMPTY, N_("Directory not empty"))
 #endif
 #ifdef EUSERS
 /*
 TRANS The file quota system is confused because there are too many users.
 TRANS @c This can probably happen in a GNU system when using NFS. */
-_S(ERR_MAP(EUSERS), N_("Too many users"))
+_S(EUSERS, N_("Too many users"))
 #endif
 #ifdef EDQUOT
 /*
 TRANS The user's disk quota was exceeded. */
-_S(ERR_MAP(EDQUOT), N_("Disk quota exceeded"))
+_S(EDQUOT, N_("Disk quota exceeded"))
 #endif
 #ifdef ESTALE
 /*
@@ -471,7 +468,7 @@ TRANS file system which is due to file system rearrangements on the server host
 TRANS for NFS file systems or corruption in other file systems.
 TRANS Repairing this condition usually requires unmounting, possibly repairing
 TRANS and remounting the file system. */
-_S(ERR_MAP(ESTALE), N_("Stale file handle"))
+_S(ESTALE, N_("Stale file handle"))
 #endif
 #ifdef EREMOTE
 /*
@@ -479,7 +476,7 @@ TRANS An attempt was made to NFS-mount a remote file system with a file name tha
 TRANS already specifies an NFS-mounted file.
 TRANS (This is an error on some operating systems, but we expect it to work
 TRANS properly on @gnuhurdsystems{}, making this error code impossible.) */
-_S(ERR_MAP(EREMOTE), N_("Object is remote"))
+_S(EREMOTE, N_("Object is remote"))
 #endif
 #ifdef ENOLCK
 /*
@@ -487,7 +484,7 @@ TRANS This is used by the file locking facilities; see
 TRANS @ref{File Locks}.  This error is never generated by @gnuhurdsystems{}, but
 TRANS it can result from an operation to an NFS server running another
 TRANS operating system. */
-_S(ERR_MAP(ENOLCK), N_("No locks available"))
+_S(ENOLCK, N_("No locks available"))
 #endif
 #ifdef ENOSYS
 /*
@@ -496,46 +493,46 @@ TRANS not implemented at all, either in the C library itself or in the
 TRANS operating system.  When you get this error, you can be sure that this
 TRANS particular function will always fail with @code{ENOSYS} unless you
 TRANS install a new version of the C library or the operating system. */
-_S(ERR_MAP(ENOSYS), N_("Function not implemented"))
+_S(ENOSYS, N_("Function not implemented"))
 #endif
 #ifdef EILSEQ
 /*
 TRANS While decoding a multibyte character the function came along an invalid
 TRANS or an incomplete sequence of bytes or the given wide character is invalid. */
-_S(ERR_MAP(EILSEQ), N_("Invalid or incomplete multibyte or wide character"))
+_S(EILSEQ, N_("Invalid or incomplete multibyte or wide character"))
 #endif
 #ifdef EBADMSG
-_S(ERR_MAP(EBADMSG), N_("Bad message"))
+_S(EBADMSG, N_("Bad message"))
 #endif
 #ifdef EIDRM
-_S(ERR_MAP(EIDRM), N_("Identifier removed"))
+_S(EIDRM, N_("Identifier removed"))
 #endif
 #ifdef EMULTIHOP
-_S(ERR_MAP(EMULTIHOP), N_("Multihop attempted"))
+_S(EMULTIHOP, N_("Multihop attempted"))
 #endif
 #ifdef ENODATA
-_S(ERR_MAP(ENODATA), N_("No data available"))
+_S(ENODATA, N_("No data available"))
 #endif
 #ifdef ENOLINK
-_S(ERR_MAP(ENOLINK), N_("Link has been severed"))
+_S(ENOLINK, N_("Link has been severed"))
 #endif
 #ifdef ENOMSG
-_S(ERR_MAP(ENOMSG), N_("No message of desired type"))
+_S(ENOMSG, N_("No message of desired type"))
 #endif
 #ifdef ENOSR
-_S(ERR_MAP(ENOSR), N_("Out of streams resources"))
+_S(ENOSR, N_("Out of streams resources"))
 #endif
 #ifdef ENOSTR
-_S(ERR_MAP(ENOSTR), N_("Device not a stream"))
+_S(ENOSTR, N_("Device not a stream"))
 #endif
 #ifdef EOVERFLOW
-_S(ERR_MAP(EOVERFLOW), N_("Value too large for defined data type"))
+_S(EOVERFLOW, N_("Value too large for defined data type"))
 #endif
 #ifdef EPROTO
-_S(ERR_MAP(EPROTO), N_("Protocol error"))
+_S(EPROTO, N_("Protocol error"))
 #endif
 #ifdef ETIME
-_S(ERR_MAP(ETIME), N_("Timer expired"))
+_S(ETIME, N_("Timer expired"))
 #endif
 #ifdef ECANCELED
 /*
@@ -543,148 +540,148 @@ TRANS An asynchronous operation was canceled before it
 TRANS completed.  @xref{Asynchronous I/O}.  When you call @code{aio_cancel},
 TRANS the normal result is for the operations affected to complete with this
 TRANS error; @pxref{Cancel AIO Operations}. */
-_S(ERR_MAP(ECANCELED), N_("Operation canceled"))
+_S(ECANCELED, N_("Operation canceled"))
 #endif
 #ifdef EOWNERDEAD
-_S(ERR_MAP(EOWNERDEAD), N_("Owner died"))
+_S(EOWNERDEAD, N_("Owner died"))
 #endif
 #ifdef ENOTRECOVERABLE
-_S(ERR_MAP(ENOTRECOVERABLE), N_("State not recoverable"))
+_S(ENOTRECOVERABLE, N_("State not recoverable"))
 #endif
 #ifdef ERESTART
-_S(ERR_MAP(ERESTART), N_("Interrupted system call should be restarted"))
+_S(ERESTART, N_("Interrupted system call should be restarted"))
 #endif
 #ifdef ECHRNG
-_S(ERR_MAP(ECHRNG), N_("Channel number out of range"))
+_S(ECHRNG, N_("Channel number out of range"))
 #endif
 #ifdef EL2NSYNC
-_S(ERR_MAP(EL2NSYNC), N_("Level 2 not synchronized"))
+_S(EL2NSYNC, N_("Level 2 not synchronized"))
 #endif
 #ifdef EL3HLT
-_S(ERR_MAP(EL3HLT), N_("Level 3 halted"))
+_S(EL3HLT, N_("Level 3 halted"))
 #endif
 #ifdef EL3RST
-_S(ERR_MAP(EL3RST), N_("Level 3 reset"))
+_S(EL3RST, N_("Level 3 reset"))
 #endif
 #ifdef ELNRNG
-_S(ERR_MAP(ELNRNG), N_("Link number out of range"))
+_S(ELNRNG, N_("Link number out of range"))
 #endif
 #ifdef EUNATCH
-_S(ERR_MAP(EUNATCH), N_("Protocol driver not attached"))
+_S(EUNATCH, N_("Protocol driver not attached"))
 #endif
 #ifdef ENOCSI
-_S(ERR_MAP(ENOCSI), N_("No CSI structure available"))
+_S(ENOCSI, N_("No CSI structure available"))
 #endif
 #ifdef EL2HLT
-_S(ERR_MAP(EL2HLT), N_("Level 2 halted"))
+_S(EL2HLT, N_("Level 2 halted"))
 #endif
 #ifdef EBADE
-_S(ERR_MAP(EBADE), N_("Invalid exchange"))
+_S(EBADE, N_("Invalid exchange"))
 #endif
 #ifdef EBADR
-_S(ERR_MAP(EBADR), N_("Invalid request descriptor"))
+_S(EBADR, N_("Invalid request descriptor"))
 #endif
 #ifdef EXFULL
-_S(ERR_MAP(EXFULL), N_("Exchange full"))
+_S(EXFULL, N_("Exchange full"))
 #endif
 #ifdef ENOANO
-_S(ERR_MAP(ENOANO), N_("No anode"))
+_S(ENOANO, N_("No anode"))
 #endif
 #ifdef EBADRQC
-_S(ERR_MAP(EBADRQC), N_("Invalid request code"))
+_S(EBADRQC, N_("Invalid request code"))
 #endif
 #ifdef EBADSLT
-_S(ERR_MAP(EBADSLT), N_("Invalid slot"))
+_S(EBADSLT, N_("Invalid slot"))
 #endif
 #ifdef EBFONT
-_S(ERR_MAP(EBFONT), N_("Bad font file format"))
+_S(EBFONT, N_("Bad font file format"))
 #endif
 #ifdef ENONET
-_S(ERR_MAP(ENONET), N_("Machine is not on the network"))
+_S(ENONET, N_("Machine is not on the network"))
 #endif
 #ifdef ENOPKG
-_S(ERR_MAP(ENOPKG), N_("Package not installed"))
+_S(ENOPKG, N_("Package not installed"))
 #endif
 #ifdef EADV
-_S(ERR_MAP(EADV), N_("Advertise error"))
+_S(EADV, N_("Advertise error"))
 #endif
 #ifdef ESRMNT
-_S(ERR_MAP(ESRMNT), N_("Srmount error"))
+_S(ESRMNT, N_("Srmount error"))
 #endif
 #ifdef ECOMM
-_S(ERR_MAP(ECOMM), N_("Communication error on send"))
+_S(ECOMM, N_("Communication error on send"))
 #endif
 #ifdef EDOTDOT
-_S(ERR_MAP(EDOTDOT), N_("RFS specific error"))
+_S(EDOTDOT, N_("RFS specific error"))
 #endif
 #ifdef ENOTUNIQ
-_S(ERR_MAP(ENOTUNIQ), N_("Name not unique on network"))
+_S(ENOTUNIQ, N_("Name not unique on network"))
 #endif
 #ifdef EBADFD
-_S(ERR_MAP(EBADFD), N_("File descriptor in bad state"))
+_S(EBADFD, N_("File descriptor in bad state"))
 #endif
 #ifdef EREMCHG
-_S(ERR_MAP(EREMCHG), N_("Remote address changed"))
+_S(EREMCHG, N_("Remote address changed"))
 #endif
 #ifdef ELIBACC
-_S(ERR_MAP(ELIBACC), N_("Can not access a needed shared library"))
+_S(ELIBACC, N_("Can not access a needed shared library"))
 #endif
 #ifdef ELIBBAD
-_S(ERR_MAP(ELIBBAD), N_("Accessing a corrupted shared library"))
+_S(ELIBBAD, N_("Accessing a corrupted shared library"))
 #endif
 #ifdef ELIBSCN
-_S(ERR_MAP(ELIBSCN), N_(".lib section in a.out corrupted"))
+_S(ELIBSCN, N_(".lib section in a.out corrupted"))
 #endif
 #ifdef ELIBMAX
-_S(ERR_MAP(ELIBMAX), N_("Attempting to link in too many shared libraries"))
+_S(ELIBMAX, N_("Attempting to link in too many shared libraries"))
 #endif
 #ifdef ELIBEXEC
-_S(ERR_MAP(ELIBEXEC), N_("Cannot exec a shared library directly"))
+_S(ELIBEXEC, N_("Cannot exec a shared library directly"))
 #endif
 #ifdef ESTRPIPE
-_S(ERR_MAP(ESTRPIPE), N_("Streams pipe error"))
+_S(ESTRPIPE, N_("Streams pipe error"))
 #endif
 #ifdef EUCLEAN
-_S(ERR_MAP(EUCLEAN), N_("Structure needs cleaning"))
+_S(EUCLEAN, N_("Structure needs cleaning"))
 #endif
 #ifdef ENOTNAM
-_S(ERR_MAP(ENOTNAM), N_("Not a XENIX named type file"))
+_S(ENOTNAM, N_("Not a XENIX named type file"))
 #endif
 #ifdef ENAVAIL
-_S(ERR_MAP(ENAVAIL), N_("No XENIX semaphores available"))
+_S(ENAVAIL, N_("No XENIX semaphores available"))
 #endif
 #ifdef EISNAM
-_S(ERR_MAP(EISNAM), N_("Is a named type file"))
+_S(EISNAM, N_("Is a named type file"))
 #endif
 #ifdef EREMOTEIO
-_S(ERR_MAP(EREMOTEIO), N_("Remote I/O error"))
+_S(EREMOTEIO, N_("Remote I/O error"))
 #endif
 #ifdef ENOMEDIUM
-_S(ERR_MAP(ENOMEDIUM), N_("No medium found"))
+_S(ENOMEDIUM, N_("No medium found"))
 #endif
 #ifdef EMEDIUMTYPE
-_S(ERR_MAP(EMEDIUMTYPE), N_("Wrong medium type"))
+_S(EMEDIUMTYPE, N_("Wrong medium type"))
 #endif
 #ifdef ENOKEY
-_S(ERR_MAP(ENOKEY), N_("Required key not available"))
+_S(ENOKEY, N_("Required key not available"))
 #endif
 #ifdef EKEYEXPIRED
-_S(ERR_MAP(EKEYEXPIRED), N_("Key has expired"))
+_S(EKEYEXPIRED, N_("Key has expired"))
 #endif
 #ifdef EKEYREVOKED
-_S(ERR_MAP(EKEYREVOKED), N_("Key has been revoked"))
+_S(EKEYREVOKED, N_("Key has been revoked"))
 #endif
 #ifdef EKEYREJECTED
-_S(ERR_MAP(EKEYREJECTED), N_("Key was rejected by service"))
+_S(EKEYREJECTED, N_("Key was rejected by service"))
 #endif
 #ifdef ERFKILL
-_S(ERR_MAP(ERFKILL), N_("Operation not possible due to RF-kill"))
+_S(ERFKILL, N_("Operation not possible due to RF-kill"))
 #endif
 #ifdef EHWPOISON
-_S(ERR_MAP(EHWPOISON), N_("Memory page has hardware error"))
+_S(EHWPOISON, N_("Memory page has hardware error"))
 #endif
 #ifdef EBADRPC
-_S(ERR_MAP(EBADRPC), N_("RPC struct is bad"))
+_S(EBADRPC, N_("RPC struct is bad"))
 #endif
 #ifdef EFTYPE
 /*
@@ -693,40 +690,40 @@ TRANS operation, or a data file had the wrong format.
 TRANS
 TRANS On some systems @code{chmod} returns this error if you try to set the
 TRANS sticky bit on a non-directory file; @pxref{Setting Permissions}. */
-_S(ERR_MAP(EFTYPE), N_("Inappropriate file type or format"))
+_S(EFTYPE, N_("Inappropriate file type or format"))
 #endif
 #ifdef EPROCUNAVAIL
-_S(ERR_MAP(EPROCUNAVAIL), N_("RPC bad procedure for program"))
+_S(EPROCUNAVAIL, N_("RPC bad procedure for program"))
 #endif
 #ifdef EAUTH
-_S(ERR_MAP(EAUTH), N_("Authentication error"))
+_S(EAUTH, N_("Authentication error"))
 #endif
 #ifdef EDIED
 /*
 TRANS On @gnuhurdsystems{}, opening a file returns this error when the file is
 TRANS translated by a program and the translator program dies while starting
 TRANS up, before it has connected to the file. */
-_S(ERR_MAP(EDIED), N_("Translator died"))
+_S(EDIED, N_("Translator died"))
 #endif
 #ifdef ERPCMISMATCH
-_S(ERR_MAP(ERPCMISMATCH), N_("RPC version wrong"))
+_S(ERPCMISMATCH, N_("RPC version wrong"))
 #endif
 #ifdef EGREGIOUS
 /*
 TRANS You did @strong{what}? */
-_S(ERR_MAP(EGREGIOUS), N_("You really blew it this time"))
+_S(EGREGIOUS, N_("You really blew it this time"))
 #endif
 #ifdef EPROCLIM
 /*
 TRANS This means that the per-user limit on new process would be exceeded by
 TRANS an attempted @code{fork}.  @xref{Limits on Resources}, for details on
 TRANS the @code{RLIMIT_NPROC} limit. */
-_S(ERR_MAP(EPROCLIM), N_("Too many processes"))
+_S(EPROCLIM, N_("Too many processes"))
 #endif
 #ifdef EGRATUITOUS
 /*
 TRANS This error code has no purpose. */
-_S(ERR_MAP(EGRATUITOUS), N_("Gratuitous error"))
+_S(EGRATUITOUS, N_("Gratuitous error"))
 #endif
 #if defined (ENOTSUP) && ENOTSUP != EOPNOTSUPP
 /*
@@ -742,10 +739,10 @@ TRANS values.
 TRANS
 TRANS If the entire function is not available at all in the implementation,
 TRANS it returns @code{ENOSYS} instead. */
-_S(ERR_MAP(ENOTSUP), N_("Not supported"))
+_S(ENOTSUP, N_("Not supported"))
 #endif
 #ifdef EPROGMISMATCH
-_S(ERR_MAP(EPROGMISMATCH), N_("RPC program version wrong"))
+_S(EPROGMISMATCH, N_("RPC program version wrong"))
 #endif
 #ifdef EBACKGROUND
 /*
@@ -755,7 +752,7 @@ TRANS foreground process group of the terminal.  Users do not usually see this
 TRANS error because functions such as @code{read} and @code{write} translate
 TRANS it into a @code{SIGTTIN} or @code{SIGTTOU} signal.  @xref{Job Control},
 TRANS for information on process groups and these signals. */
-_S(ERR_MAP(EBACKGROUND), N_("Inappropriate operation for background process"))
+_S(EBACKGROUND, N_("Inappropriate operation for background process"))
 #endif
 #ifdef EIEIO
 /*
@@ -773,7 +770,7 @@ TRANS @c "bought the farm" means "died".  -jtobey
 TRANS @c
 TRANS @c Translators, please do not translate this litteraly, translate it into
 TRANS @c an idiomatic funny way of saying that the computer died. */
-_S(ERR_MAP(EIEIO), N_("Computer bought the farm"))
+_S(EIEIO, N_("Computer bought the farm"))
 #endif
 #if defined (EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
 /*
@@ -782,18 +779,18 @@ TRANS The values are always the same, on every operating system.
 TRANS
 TRANS C libraries in many older Unix systems have @code{EWOULDBLOCK} as a
 TRANS separate error code. */
-_S(ERR_MAP(EWOULDBLOCK), N_("Operation would block"))
+_S(EWOULDBLOCK, N_("Operation would block"))
 #endif
 #ifdef ENEEDAUTH
-_S(ERR_MAP(ENEEDAUTH), N_("Need authenticator"))
+_S(ENEEDAUTH, N_("Need authenticator"))
 #endif
 #ifdef ED
 /*
 TRANS The experienced user will know what is wrong.
 TRANS @c This error code is a joke.  Its perror text is part of the joke.
 TRANS @c Don't change it. */
-_S(ERR_MAP(ED), N_("?"))
+_S(ED, N_("?"))
 #endif
 #ifdef EPROGUNAVAIL
-_S(ERR_MAP(EPROGUNAVAIL), N_("RPC program not available"))
+_S(EPROGUNAVAIL, N_("RPC program not available"))
 #endif
diff --git a/sysdeps/unix/sysv/linux/Makefile b/sysdeps/unix/sysv/linux/Makefile
index 9b2a253032..34748ffcd1 100644
--- a/sysdeps/unix/sysv/linux/Makefile
+++ b/sysdeps/unix/sysv/linux/Makefile
@@ -100,7 +100,7 @@ tests += tst-clone tst-clone2 tst-clone3 tst-fanotify tst-personality \
 	 tst-quota tst-sync_file_range tst-sysconf-iov_max tst-ttyname \
 	 test-errno-linux tst-memfd_create tst-mlock2 tst-pkey \
 	 tst-rlimit-infinity tst-ofdlocks tst-gettid tst-gettid-kill \
-	 tst-tgkill
+	 tst-tgkill tst-sysvsem-linux tst-sysvmsg-linux tst-sysvshm-linux
 tests-internal += tst-ofdlocks-compat tst-sigcontext-get_pc
 
 CFLAGS-tst-sigcontext-get_pc.c = -fasynchronous-unwind-tables
diff --git a/sysdeps/unix/sysv/linux/aarch64/configure b/sysdeps/unix/sysv/linux/aarch64/configure
index 27d50e1d3c..290670a67a 100644
--- a/sysdeps/unix/sysv/linux/aarch64/configure
+++ b/sysdeps/unix/sysv/linux/aarch64/configure
@@ -6,10 +6,10 @@ arch_minimum_kernel=3.7.0
 test -n "$libc_cv_slibdir" ||
 case "$prefix" in
 /usr | /usr/)
-  libc_cv_slibdir='/lib64'
+  libc_cv_slibdir='/lib'
   libc_cv_rtlddir='/lib'
   if test "$libdir" = '${exec_prefix}/lib'; then
-    libdir='${exec_prefix}/lib64';
+    libdir='${exec_prefix}/lib';
     # Locale data can be shared between 32-bit and 64-bit libraries.
     libc_cv_complocaledir='${exec_prefix}/lib/locale'
   fi
diff --git a/sysdeps/unix/sysv/linux/aarch64/cpu-features.h b/sysdeps/unix/sysv/linux/aarch64/cpu-features.h
index fc688450ee..00a4d0c8e7 100644
--- a/sysdeps/unix/sysv/linux/aarch64/cpu-features.h
+++ b/sysdeps/unix/sysv/linux/aarch64/cpu-features.h
@@ -54,6 +54,10 @@
                         && MIDR_PARTNUM(midr) == 0x000)
 #define IS_NEOVERSE_N1(midr) (MIDR_IMPLEMENTOR(midr) == 'A'		      \
 			      && MIDR_PARTNUM(midr) == 0xd0c)
+#define IS_NEOVERSE_N2(midr) (MIDR_IMPLEMENTOR(midr) == 'A'		      \
+			      && MIDR_PARTNUM(midr) == 0xd49)
+#define IS_NEOVERSE_V1(midr) (MIDR_IMPLEMENTOR(midr) == 'A'		      \
+			      && MIDR_PARTNUM(midr) == 0xd40)
 
 #define IS_EMAG(midr) (MIDR_IMPLEMENTOR(midr) == 'P'			      \
                        && MIDR_PARTNUM(midr) == 0x000)
diff --git a/sysdeps/unix/sysv/linux/msgctl.c b/sysdeps/unix/sysv/linux/msgctl.c
index 0776472d5e..a1f24ab242 100644
--- a/sysdeps/unix/sysv/linux/msgctl.c
+++ b/sysdeps/unix/sysv/linux/msgctl.c
@@ -90,8 +90,15 @@ __msgctl64 (int msqid, int cmd, struct __msqid64_ds *buf)
   struct kernel_msqid64_ds ksemid, *arg = NULL;
   if (buf != NULL)
     {
-      msqid64_to_kmsqid64 (buf, &ksemid);
-      arg = &ksemid;
+      /* This is a Linux extension where kernel returns a 'struct msginfo'
+	 instead.  */
+      if (cmd == IPC_INFO || cmd == MSG_INFO)
+	arg = (struct kernel_msqid64_ds *) buf;
+      else
+	{
+	  msqid64_to_kmsqid64 (buf, &ksemid);
+	  arg = &ksemid;
+	}
     }
 # ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
   if (cmd == IPC_SET)
@@ -169,8 +176,15 @@ __msgctl (int msqid, int cmd, struct msqid_ds *buf)
   struct __msqid64_ds msqid64, *buf64 = NULL;
   if (buf != NULL)
     {
-      msqid_to_msqid64 (&msqid64, buf);
-      buf64 = &msqid64;
+      /* This is a Linux extension where kernel returns a 'struct msginfo'
+	 instead.  */
+      if (cmd == IPC_INFO || cmd == MSG_INFO)
+	buf64 = (struct __msqid64_ds *) buf;
+      else
+	{
+	  msqid_to_msqid64 (&msqid64, buf);
+	  buf64 = &msqid64;
+	}
     }
 
   int ret = __msgctl64 (msqid, cmd, buf64);
diff --git a/sysdeps/unix/sysv/linux/semctl.c b/sysdeps/unix/sysv/linux/semctl.c
index f131a26fc7..1cdabde8f2 100644
--- a/sysdeps/unix/sysv/linux/semctl.c
+++ b/sysdeps/unix/sysv/linux/semctl.c
@@ -102,6 +102,7 @@ semun64_to_ksemun64 (int cmd, union semun64 semun64,
       r.array = semun64.array;
       break;
     case SEM_STAT:
+    case SEM_STAT_ANY:
     case IPC_STAT:
     case IPC_SET:
       r.buf = buf;
@@ -150,6 +151,7 @@ __semctl64 (int semid, int semnum, int cmd, ...)
     case IPC_STAT:      /* arg.buf */
     case IPC_SET:
     case SEM_STAT:
+    case SEM_STAT_ANY:
     case IPC_INFO:      /* arg.__buf */
     case SEM_INFO:
       va_start (ap, cmd);
@@ -238,6 +240,7 @@ semun_to_semun64 (int cmd, union semun semun, struct __semid64_ds *semid64)
       r.array = semun.array;
       break;
     case SEM_STAT:
+    case SEM_STAT_ANY:
     case IPC_STAT:
     case IPC_SET:
       r.buf = semid64;
@@ -267,6 +270,7 @@ __semctl (int semid, int semnum, int cmd, ...)
     case IPC_STAT:      /* arg.buf */
     case IPC_SET:
     case SEM_STAT:
+    case SEM_STAT_ANY:
     case IPC_INFO:      /* arg.__buf */
     case SEM_INFO:
       va_start (ap, cmd);
@@ -321,6 +325,7 @@ __semctl_mode16 (int semid, int semnum, int cmd, ...)
     case IPC_STAT:      /* arg.buf */
     case IPC_SET:
     case SEM_STAT:
+    case SEM_STAT_ANY:
     case IPC_INFO:      /* arg.__buf */
     case SEM_INFO:
       va_start (ap, cmd);
@@ -354,6 +359,7 @@ __old_semctl (int semid, int semnum, int cmd, ...)
     case IPC_STAT:      /* arg.buf */
     case IPC_SET:
     case SEM_STAT:
+    case SEM_STAT_ANY:
     case IPC_INFO:      /* arg.__buf */
     case SEM_INFO:
       va_start (ap, cmd);
diff --git a/sysdeps/unix/sysv/linux/shmctl.c b/sysdeps/unix/sysv/linux/shmctl.c
index 76d88441f1..1d19a798b1 100644
--- a/sysdeps/unix/sysv/linux/shmctl.c
+++ b/sysdeps/unix/sysv/linux/shmctl.c
@@ -90,8 +90,15 @@ __shmctl64 (int shmid, int cmd, struct __shmid64_ds *buf)
   struct kernel_shmid64_ds kshmid, *arg = NULL;
   if (buf != NULL)
     {
-      shmid64_to_kshmid64 (buf, &kshmid);
-      arg = &kshmid;
+      /* This is a Linux extension where kernel expects either a
+	 'struct shminfo' (IPC_INFO) or 'struct shm_info' (SHM_INFO).  */
+      if (cmd == IPC_INFO || cmd == SHM_INFO)
+	arg = (struct kernel_shmid64_ds *) buf;
+      else
+	{
+	  shmid64_to_kshmid64 (buf, &kshmid);
+	  arg = &kshmid;
+	}
     }
 # ifdef __ASSUME_SYSVIPC_BROKEN_MODE_T
   if (cmd == IPC_SET)
@@ -107,7 +114,6 @@ __shmctl64 (int shmid, int cmd, struct __shmid64_ds *buf)
 
   switch (cmd)
     {
-      case IPC_INFO:
       case IPC_STAT:
       case SHM_STAT:
       case SHM_STAT_ANY:
@@ -168,8 +174,15 @@ __shmctl (int shmid, int cmd, struct shmid_ds *buf)
   struct __shmid64_ds shmid64, *buf64 = NULL;
   if (buf != NULL)
     {
-      shmid_to_shmid64 (&shmid64, buf);
-      buf64 = &shmid64;
+      /* This is a Linux extension where kernel expects either a
+	 'struct shminfo' (IPC_INFO) or 'struct shm_info' (SHM_INFO).  */
+      if (cmd == IPC_INFO || cmd == SHM_INFO)
+	buf64 = (struct __shmid64_ds *) buf;
+      else
+	{
+	  shmid_to_shmid64 (&shmid64, buf);
+	  buf64 = &shmid64;
+	}
     }
 
   int ret = __shmctl64 (shmid, cmd, buf64);
@@ -178,7 +191,6 @@ __shmctl (int shmid, int cmd, struct shmid_ds *buf)
 
   switch (cmd)
     {
-      case IPC_INFO:
       case IPC_STAT:
       case SHM_STAT:
       case SHM_STAT_ANY:
diff --git a/sysdeps/unix/sysv/linux/tst-sysvmsg-linux.c b/sysdeps/unix/sysv/linux/tst-sysvmsg-linux.c
new file mode 100644
index 0000000000..630f4f792c
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/tst-sysvmsg-linux.c
@@ -0,0 +1,177 @@
+/* Basic tests for Linux SYSV message queue extensions.
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sys/ipc.h>
+#include <sys/msg.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdio.h>
+
+#include <support/check.h>
+#include <support/temp_file.h>
+
+#define MSGQ_MODE 0644
+
+/* These are for the temporary file we generate.  */
+static char *name;
+static int msqid;
+
+static void
+remove_msq (void)
+{
+  /* Enforce message queue removal in case of early test failure.
+     Ignore error since the msg may already have being removed.  */
+  msgctl (msqid, IPC_RMID, NULL);
+}
+
+static void
+do_prepare (int argc, char *argv[])
+{
+  TEST_VERIFY_EXIT (create_temp_file ("tst-sysvmsg.", &name) != -1);
+}
+
+#define PREPARE do_prepare
+
+struct test_msginfo
+{
+  int msgmax;
+  int msgmnb;
+  int msgmni;
+};
+
+/* It tries to obtain some system-wide SysV messsage queue information from
+   /proc to check against IPC_INFO/MSG_INFO.  The /proc only returns the
+   tunables value of MSGMAX, MSGMNB, and MSGMNI.
+
+   The kernel also returns constant value for MSGSSZ, MSGSEG and also MSGMAP,
+   MSGPOOL, and MSGTQL (for IPC_INFO).  The issue to check them is they might
+   change over kernel releases.  */
+
+static int
+read_proc_file (const char *file)
+{
+  FILE *f = fopen (file, "r");
+  if (f == NULL)
+    FAIL_UNSUPPORTED ("/proc is not mounted or %s is not available", file);
+
+  int v;
+  int r = fscanf (f, "%d", & v);
+  TEST_VERIFY_EXIT (r == 1);
+
+  fclose (f);
+  return v;
+}
+
+
+/* Check if the message queue with IDX (index into the kernel's internal
+   array) matches the one with KEY.  The CMD is either MSG_STAT or
+   MSG_STAT_ANY.  */
+
+static bool
+check_msginfo (int idx, key_t key, int cmd)
+{
+  struct msqid_ds msginfo;
+  int mid = msgctl (idx, cmd, &msginfo);
+  /* Ignore unused array slot returned by the kernel or information from
+     unknown message queue.  */
+  if ((mid == -1 && errno == EINVAL) || mid != msqid)
+    return false;
+
+  if (mid == -1)
+    FAIL_EXIT1 ("msgctl with %s failed: %m",
+		cmd == MSG_STAT ? "MSG_STAT" : "MSG_STAT_ANY");
+
+  TEST_COMPARE (msginfo.msg_perm.__key, key);
+  TEST_COMPARE (msginfo.msg_perm.mode, MSGQ_MODE);
+  TEST_COMPARE (msginfo.msg_qnum, 0);
+
+  return true;
+}
+
+static int
+do_test (void)
+{
+  atexit (remove_msq);
+
+  key_t key = ftok (name, 'G');
+  if (key == -1)
+    FAIL_EXIT1 ("ftok failed: %m");
+
+  msqid = msgget (key, MSGQ_MODE | IPC_CREAT);
+  if (msqid == -1)
+    FAIL_EXIT1 ("msgget failed: %m");
+
+  struct test_msginfo tipcinfo;
+  tipcinfo.msgmax = read_proc_file ("/proc/sys/kernel/msgmax");
+  tipcinfo.msgmnb = read_proc_file ("/proc/sys/kernel/msgmnb");
+  tipcinfo.msgmni = read_proc_file ("/proc/sys/kernel/msgmni");
+
+  int msqidx;
+
+  {
+    struct msginfo ipcinfo;
+    msqidx = msgctl (msqid, IPC_INFO, (struct msqid_ds *) &ipcinfo);
+    if (msqidx == -1)
+      FAIL_EXIT1 ("msgctl with IPC_INFO failed: %m");
+
+    TEST_COMPARE (ipcinfo.msgmax, tipcinfo.msgmax);
+    TEST_COMPARE (ipcinfo.msgmnb, tipcinfo.msgmnb);
+    TEST_COMPARE (ipcinfo.msgmni, tipcinfo.msgmni);
+  }
+
+  /* Same as before but with MSG_INFO.  */
+  {
+    struct msginfo ipcinfo;
+    msqidx = msgctl (msqid, MSG_INFO, (struct msqid_ds *) &ipcinfo);
+    if (msqidx == -1)
+      FAIL_EXIT1 ("msgctl with IPC_INFO failed: %m");
+
+    TEST_COMPARE (ipcinfo.msgmax, tipcinfo.msgmax);
+    TEST_COMPARE (ipcinfo.msgmnb, tipcinfo.msgmnb);
+    TEST_COMPARE (ipcinfo.msgmni, tipcinfo.msgmni);
+  }
+
+  /* We check if the created message queue shows in global list.  */
+  bool found = false;
+  for (int i = 0; i <= msqidx; i++)
+    {
+      /* We can't tell apart if MSG_STAT_ANY is not supported (kernel older
+	 than 4.17) or if the index used is invalid.  So it just check if the
+	 value returned from a valid call matches the created message
+	 queue.  */
+      check_msginfo (i, key, MSG_STAT_ANY);
+
+      if (check_msginfo (i, key, MSG_STAT))
+	{
+	  found = true;
+	  break;
+	}
+    }
+
+  if (!found)
+    FAIL_EXIT1 ("msgctl with MSG_STAT/MSG_STAT_ANY could not find the "
+		"created message queue");
+
+  if (msgctl (msqid, IPC_RMID, NULL) == -1)
+    FAIL_EXIT1 ("msgctl failed");
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/unix/sysv/linux/tst-sysvsem-linux.c b/sysdeps/unix/sysv/linux/tst-sysvsem-linux.c
new file mode 100644
index 0000000000..45f19e2d37
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/tst-sysvsem-linux.c
@@ -0,0 +1,184 @@
+/* Basic tests for Linux SYSV semaphore extensions.
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sys/ipc.h>
+#include <sys/sem.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdio.h>
+
+#include <support/check.h>
+#include <support/temp_file.h>
+
+/* These are for the temporary file we generate.  */
+static char *name;
+static int semid;
+
+static void
+remove_sem (void)
+{
+  /* Enforce message queue removal in case of early test failure.
+     Ignore error since the sem may already have being removed.  */
+  semctl (semid, 0, IPC_RMID, 0);
+}
+
+static void
+do_prepare (int argc, char *argv[])
+{
+  TEST_VERIFY_EXIT (create_temp_file ("tst-sysvsem.", &name) != -1);
+}
+
+#define PREPARE do_prepare
+
+#define SEM_MODE 0644
+
+union semun
+{
+  int val;
+  struct semid_ds *buf;
+  unsigned short  *array;
+  struct seminfo *__buf;
+};
+
+struct test_seminfo
+{
+  int semmsl;
+  int semmns;
+  int semopm;
+  int semmni;
+};
+
+/* It tries to obtain some system-wide SysV semaphore information from /proc
+   to check against IPC_INFO/SEM_INFO.  The /proc only returns the tunables
+   value of SEMMSL, SEMMNS, SEMOPM, and SEMMNI.
+
+   The kernel also returns constant value for SEMVMX, SEMMNU, SEMMAP, SEMUME,
+   and also SEMUSZ and SEMAEM (for IPC_INFO).  The issue to check them is they
+   might change over kernel releases.  */
+
+static void
+read_sem_stat (struct test_seminfo *tseminfo)
+{
+  FILE *f = fopen ("/proc/sys/kernel/sem", "r");
+  if (f == NULL)
+    FAIL_UNSUPPORTED ("/proc is not mounted or /proc/sys/kernel/sem is not "
+		      "available");
+
+  int r = fscanf (f, "%d %d %d %d",
+		  &tseminfo->semmsl, &tseminfo->semmns, &tseminfo->semopm,
+		  &tseminfo->semmni);
+  TEST_VERIFY_EXIT (r == 4);
+
+  fclose (f);
+}
+
+
+/* Check if the semaphore with IDX (index into the kernel's internal array)
+   matches the one with KEY.  The CMD is either SEM_STAT or SEM_STAT_ANY.  */
+
+static bool
+check_seminfo (int idx, key_t key, int cmd)
+{
+  struct semid_ds seminfo;
+  int sid = semctl (idx, 0, cmd, (union semun) { .buf = &seminfo });
+  /* Ignore unused array slot returned by the kernel or information from
+     unknown semaphores.  */
+  if ((sid == -1 && errno == EINVAL) || sid != semid)
+    return false;
+
+  if (sid == -1)
+    FAIL_EXIT1 ("semctl with SEM_STAT failed (errno=%d)", errno);
+
+  TEST_COMPARE (seminfo.sem_perm.__key, key);
+  TEST_COMPARE (seminfo.sem_perm.mode, SEM_MODE);
+  TEST_COMPARE (seminfo.sem_nsems, 1);
+
+  return true;
+}
+
+static int
+do_test (void)
+{
+  atexit (remove_sem);
+
+  key_t key = ftok (name, 'G');
+  if (key == -1)
+    FAIL_EXIT1 ("ftok failed: %m");
+
+  semid = semget (key, 1, IPC_CREAT | IPC_EXCL | SEM_MODE);
+  if (semid == -1)
+    FAIL_EXIT1 ("semget failed: %m");
+
+  struct test_seminfo tipcinfo;
+  read_sem_stat (&tipcinfo);
+
+  int semidx;
+
+  {
+    struct seminfo ipcinfo;
+    semidx = semctl (semid, 0, IPC_INFO, (union semun) { .__buf = &ipcinfo });
+    if (semidx == -1)
+      FAIL_EXIT1 ("semctl with IPC_INFO failed: %m");
+
+    TEST_COMPARE (ipcinfo.semmsl, tipcinfo.semmsl);
+    TEST_COMPARE (ipcinfo.semmns, tipcinfo.semmns);
+    TEST_COMPARE (ipcinfo.semopm, tipcinfo.semopm);
+    TEST_COMPARE (ipcinfo.semmni, tipcinfo.semmni);
+  }
+
+  /* Same as before but with SEM_INFO.  */
+  {
+    struct seminfo ipcinfo;
+    semidx = semctl (semid, 0, SEM_INFO, (union semun) { .__buf = &ipcinfo });
+    if (semidx == -1)
+      FAIL_EXIT1 ("semctl with IPC_INFO failed: %m");
+
+    TEST_COMPARE (ipcinfo.semmsl, tipcinfo.semmsl);
+    TEST_COMPARE (ipcinfo.semmns, tipcinfo.semmns);
+    TEST_COMPARE (ipcinfo.semopm, tipcinfo.semopm);
+    TEST_COMPARE (ipcinfo.semmni, tipcinfo.semmni);
+  }
+
+  /* We check if the created semaphore shows in the system-wide status.  */
+  bool found = false;
+  for (int i = 0; i <= semidx; i++)
+    {
+      /* We can't tell apart if SEM_STAT_ANY is not supported (kernel older
+	 than 4.17) or if the index used is invalid.  So it just check if
+	 value returned from a valid call matches the created semaphore.  */
+      check_seminfo (i, key, SEM_STAT_ANY);
+
+      if (check_seminfo (i, key, SEM_STAT))
+	{
+	  found = true;
+	  break;
+	}
+    }
+
+  if (!found)
+    FAIL_EXIT1 ("semctl with SEM_STAT/SEM_STAT_ANY could not find the "
+		"created  semaphore");
+
+  if (semctl (semid, 0, IPC_RMID, 0) == -1)
+    FAIL_EXIT1 ("semctl failed: %m");
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/unix/sysv/linux/tst-sysvshm-linux.c b/sysdeps/unix/sysv/linux/tst-sysvshm-linux.c
new file mode 100644
index 0000000000..7128ae2e14
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/tst-sysvshm-linux.c
@@ -0,0 +1,185 @@
+/* Basic tests for Linux SYSV shared memory extensions.
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <inttypes.h>
+#include <limits.h>
+
+#include <support/check.h>
+#include <support/temp_file.h>
+
+#define SHM_MODE 0644
+
+/* These are for the temporary file we generate.  */
+static char *name;
+static int shmid;
+static long int pgsz;
+
+static void
+remove_shm (void)
+{
+  /* Enforce message queue removal in case of early test failure.
+     Ignore error since the shm may already have being removed.  */
+  shmctl (shmid, IPC_RMID, NULL);
+}
+
+static void
+do_prepare (int argc, char *argv[])
+{
+  TEST_VERIFY_EXIT (create_temp_file ("tst-sysvshm.", &name) != -1);
+}
+
+#define PREPARE do_prepare
+
+struct test_shminfo
+{
+  unsigned long int shmall;
+  unsigned long int shmmax;
+  unsigned long int shmmni;
+};
+
+/* It tries to obtain some system-wide SysV shared memory information from
+   /proc to check against IPC_INFO/SHM_INFO.  The /proc only returns the
+   tunables value of SHMALL, SHMMAX, and SHMMNI.  */
+
+static uint64_t
+read_proc_file (const char *file)
+{
+  FILE *f = fopen (file, "r");
+  if (f == NULL)
+    FAIL_UNSUPPORTED ("/proc is not mounted or %s is not available", file);
+
+  /* Handle 32-bit binaries running on 64-bit kernels.  */
+  uint64_t v;
+  int r = fscanf (f, "%" SCNu64, &v);
+  TEST_VERIFY_EXIT (r == 1);
+
+  fclose (f);
+  return v;
+}
+
+
+/* Check if the message queue with IDX (index into the kernel's internal
+   array) matches the one with KEY.  The CMD is either SHM_STAT or
+   SHM_STAT_ANY.  */
+
+static bool
+check_shminfo (int idx, key_t key, int cmd)
+{
+  struct shmid_ds shminfo;
+  int sid = shmctl (idx, cmd, &shminfo);
+  /* Ignore unused array slot returned by the kernel or information from
+     unknown message queue.  */
+  if ((sid == -1 && errno == EINVAL) || sid != shmid)
+    return false;
+
+  if (sid == -1)
+    FAIL_EXIT1 ("shmctl with %s failed: %m",
+		cmd == SHM_STAT ? "SHM_STAT" : "SHM_STAT_ANY");
+
+  TEST_COMPARE (shminfo.shm_perm.__key, key);
+  TEST_COMPARE (shminfo.shm_perm.mode, SHM_MODE);
+  TEST_COMPARE (shminfo.shm_segsz, pgsz);
+
+  return true;
+}
+
+static int
+do_test (void)
+{
+  atexit (remove_shm);
+
+  pgsz = sysconf (_SC_PAGESIZE);
+  if (pgsz == -1)
+    FAIL_EXIT1 ("sysconf (_SC_PAGESIZE) failed: %m");
+
+  key_t key = ftok (name, 'G');
+  if (key == -1)
+    FAIL_EXIT1 ("ftok failed: %m");
+
+  shmid = shmget (key, pgsz, IPC_CREAT | IPC_EXCL | SHM_MODE);
+  if (shmid == -1)
+    FAIL_EXIT1 ("shmget failed: %m");
+
+  struct test_shminfo tipcinfo;
+  {
+    uint64_t v = read_proc_file ("/proc/sys/kernel/shmmax");
+#if LONG_MAX == INT_MAX
+    /* Kernel explicit clamp the value for shmmax on compat symbol (32-bit
+       binaries running on 64-bit kernels).  */
+    if (v > INT_MAX)
+      v = INT_MAX;
+#endif
+    tipcinfo.shmmax = v;
+  }
+  tipcinfo.shmall = read_proc_file ("/proc/sys/kernel/shmall");
+  tipcinfo.shmmni = read_proc_file ("/proc/sys/kernel/shmmni");
+
+  int shmidx;
+
+  /* Note: SHM_INFO does not return a shminfo, but rather a 'struct shm_info'.
+     It is tricky to verify its values since the syscall returns system wide
+     resources consumed by shared memory.  The shmctl implementation handles
+     SHM_INFO as IPC_INFO, so the IPC_INFO test should validate SHM_INFO as
+     well.  */
+
+  {
+    struct shminfo ipcinfo;
+    shmidx = shmctl (shmid, IPC_INFO, (struct shmid_ds *) &ipcinfo);
+    if (shmidx == -1)
+      FAIL_EXIT1 ("shmctl with IPC_INFO failed: %m");
+
+    TEST_COMPARE (ipcinfo.shmall, tipcinfo.shmall);
+    TEST_COMPARE (ipcinfo.shmmax, tipcinfo.shmmax);
+    TEST_COMPARE (ipcinfo.shmmni, tipcinfo.shmmni);
+  }
+
+  /* We check if the created shared memory shows in the global list.  */
+  bool found = false;
+  for (int i = 0; i <= shmidx; i++)
+    {
+      /* We can't tell apart if SHM_STAT_ANY is not supported (kernel older
+	 than 4.17) or if the index used is invalid.  So it just check if
+	 value returned from a valid call matches the created message
+	 queue.  */
+      check_shminfo (i, key, SHM_STAT_ANY);
+
+      if (check_shminfo (i, key, SHM_STAT))
+	{
+	  found = true;
+	  break;
+	}
+    }
+
+  if (!found)
+    FAIL_EXIT1 ("shmctl with SHM_STAT/SHM_STAT_ANY could not find the "
+		"created shared memory");
+
+  if (shmctl (shmid, IPC_RMID, NULL) == -1)
+    FAIL_EXIT1 ("shmctl failed");
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/64/configure b/sysdeps/unix/sysv/linux/x86_64/64/configure
index 9d298faba7..cef1ec842c 100644
--- a/sysdeps/unix/sysv/linux/x86_64/64/configure
+++ b/sysdeps/unix/sysv/linux/x86_64/64/configure
@@ -4,10 +4,10 @@
 test -n "$libc_cv_slibdir" ||
 case "$prefix" in
 /usr | /usr/)
-  libc_cv_slibdir='/lib64'
-  libc_cv_rtlddir='/lib64'
+  libc_cv_slibdir='/lib'
+  libc_cv_rtlddir='/lib'
   if test "$libdir" = '${exec_prefix}/lib'; then
-    libdir='${exec_prefix}/lib64';
+    libdir='${exec_prefix}/lib';
     # Locale data can be shared between 32-bit and 64-bit libraries.
     libc_cv_complocaledir='${exec_prefix}/lib/locale'
   fi
diff --git a/sysdeps/unix/sysv/linux/x86_64/ldconfig.h b/sysdeps/unix/sysv/linux/x86_64/ldconfig.h
index 062c04689d..7783757726 100644
--- a/sysdeps/unix/sysv/linux/x86_64/ldconfig.h
+++ b/sysdeps/unix/sysv/linux/x86_64/ldconfig.h
@@ -18,9 +18,9 @@
 #include <sysdeps/generic/ldconfig.h>
 
 #define SYSDEP_KNOWN_INTERPRETER_NAMES \
-  { "/lib/ld-linux.so.2", FLAG_ELF_LIBC6 }, \
+  { "/lib32/ld-linux.so.2", FLAG_ELF_LIBC6 }, \
   { "/libx32/ld-linux-x32.so.2", FLAG_ELF_LIBC6 }, \
-  { "/lib64/ld-linux-x86-64.so.2", FLAG_ELF_LIBC6 },
+  { "/lib/ld-linux-x86-64.so.2", FLAG_ELF_LIBC6 },
 #define SYSDEP_KNOWN_LIBRARY_NAMES \
   { "libc.so.6", FLAG_ELF_LIBC6 },	\
   { "libm.so.6", FLAG_ELF_LIBC6 },
diff --git a/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed b/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed
index 44d76e8aa1..7d6cb1e20b 100644
--- a/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed
+++ b/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed
@@ -1,3 +1,3 @@
 /LD_TRACE_LOADED_OBJECTS=1/a\
 add_env="$add_env LD_LIBRARY_VERSION=\\$verify_out"
-s_^\(RTLDLIST=\)\(.*lib\)\(\|64\|x32\)\(/[^/]*\)\(-x86-64\|-x32\)\(\.so\.[0-9.]*\)[ 	]*$_\1"\2\4\6 \264\4-x86-64\6 \2x32\4-x32\6"_
+s_^\(RTLDLIST=\)\(.*lib\)\(\|64\|x32\)\(/[^/]*\)\(-x86-64\|-x32\)\(\.so\.[0-9.]*\)[    ]*$_\1"\232\4\6 \2\4-x86-64\6 \2x32\4-x32\6"_
diff --git a/sysdeps/x86_64/fpu/multiarch/ifunc-fma4.h b/sysdeps/x86_64/fpu/multiarch/ifunc-fma4.h
index 7659758972..e5fd5ac9cb 100644
--- a/sysdeps/x86_64/fpu/multiarch/ifunc-fma4.h
+++ b/sysdeps/x86_64/fpu/multiarch/ifunc-fma4.h
@@ -32,7 +32,7 @@ IFUNC_SELECTOR (void)
       && CPU_FEATURE_USABLE_P (cpu_features, AVX2))
     return OPTIMIZE (fma);
 
-  if (CPU_FEATURE_USABLE_P (cpu_features, FMA))
+  if (CPU_FEATURE_USABLE_P (cpu_features, FMA4))
     return OPTIMIZE (fma4);
 
   return OPTIMIZE (sse2);
diff --git a/sysvipc/test-sysvsem.c b/sysvipc/test-sysvsem.c
index 01dbff343a..b7284e0b48 100644
--- a/sysvipc/test-sysvsem.c
+++ b/sysvipc/test-sysvsem.c
@@ -20,6 +20,7 @@
 #include <stdlib.h>
 #include <errno.h>
 #include <string.h>
+#include <stdbool.h>
 #include <sys/types.h>
 #include <sys/ipc.h>
 #include <sys/sem.h>
diff --git a/version.h b/version.h
index 83cd196798..e6ca7a8857 100644
--- a/version.h
+++ b/version.h
@@ -1,4 +1,4 @@
 /* This file just defines the current version number of libc.  */
 
-#define RELEASE "release"
+#define RELEASE "stable"
 #define VERSION "2.32"
